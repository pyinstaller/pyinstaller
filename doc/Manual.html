<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>PyInstaller Manual</title>
<meta name="authors" content="David Cortesi  based on structure by Giovanni Bajo &amp; William Caban  based on Gordon McMillan's manual" />
<meta name="copyright" content="This document has been placed in the public domain." />
<link rel="stylesheet" href="stylesheets/default.css" type="text/css" />
</head>
<body>
<div class="document" id="pyinstaller-manual">
<h1 class="title">PyInstaller Manual</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Version:</th>
<td>PyInstaller 2.1.1dev-3607bf4</td></tr>
<tr class="field"><th class="docinfo-name">Homepage:</th><td class="field-body"><a class="reference external" href="http://www.pyinstaller.org">http://www.pyinstaller.org</a></td>
</tr>
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first last reference external" href="mailto:pyinstaller&#64;googlegroups.com">pyinstaller&#64;googlegroups.com</a></td></tr>
<tr><th class="docinfo-name">Authors:</th>
<td>David Cortesi
<br />based on structure by Giovanni Bajo &amp; William Caban
<br />based on Gordon McMillan's manual</td></tr>
<tr><th class="docinfo-name">Copyright:</th>
<td>This document has been placed in the public domain.</td></tr>
</tbody>
</table>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#requirements" id="id3">Requirements</a></li>
<li><a class="reference internal" href="#license" id="id4">License</a></li>
<li><a class="reference internal" href="#how-to-contribute" id="id5">How To Contribute</a></li>
<li><a class="reference internal" href="#installing-pyinstaller" id="id6">Installing <cite>PyInstaller</cite></a><ul>
<li><a class="reference internal" href="#installing-using-pip" id="id7">Installing Using pip</a><ul>
<li><a class="reference internal" href="#installing-in-windows" id="id8">Installing in Windows</a></li>
</ul>
</li>
<li><a class="reference internal" href="#installing-from-the-archive" id="id9">Installing from the archive</a></li>
<li><a class="reference internal" href="#verifying-the-installation" id="id10">Verifying the installation</a></li>
<li><a class="reference internal" href="#installed-commands" id="id11">Installed commands</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overview-what-pyinstaller-does-and-how-it-does-it" id="id12">Overview: What <cite>PyInstaller</cite> Does and How It Does It</a><ul>
<li><a class="reference internal" href="#analysis-finding-the-files-your-program-needs" id="id13">Analysis: Finding the Files Your Program Needs</a></li>
<li><a class="reference internal" href="#bundling-to-one-folder" id="id14">Bundling to One Folder</a></li>
<li><a class="reference internal" href="#bundling-to-one-file" id="id15">Bundling to One File</a></li>
<li><a class="reference internal" href="#how-the-one-folder-program-works" id="id16">How the One-Folder Program Works</a></li>
<li><a class="reference internal" href="#how-the-one-file-program-works" id="id17">How the One-File Program Works</a></li>
<li><a class="reference internal" href="#console-or-not" id="id18">Console or not?</a></li>
<li><a class="reference internal" href="#hiding-the-source-code" id="id19">Hiding the Source Code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-pyinstaller" id="id20">Using PyInstaller</a><ul>
<li><a class="reference internal" href="#options" id="id21">Options</a><ul>
<li><a class="reference internal" href="#general-options" id="id22">General Options</a></li>
<li><a class="reference internal" href="#what-to-generate" id="id23">What to generate</a></li>
<li><a class="reference internal" href="#what-to-bundle-where-to-search" id="id24">What to bundle, where to search</a></li>
<li><a class="reference internal" href="#how-to-generate" id="id25">How to generate</a></li>
<li><a class="reference internal" href="#windows-and-mac-os-x-specific-options" id="id26">Windows and Mac OS X specific options</a></li>
<li><a class="reference internal" href="#windows-specific-options" id="id27">Windows specific options</a></li>
<li><a class="reference internal" href="#mac-os-x-specific-options" id="id28">Mac OS X specific options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#building-mac-os-x-app-bundles" id="id29">Building Mac OS X App Bundles</a><ul>
<li><a class="reference internal" href="#setting-a-custom-icon" id="id30">Setting a Custom Icon</a></li>
<li><a class="reference internal" href="#setting-the-supported-document-types" id="id31">Setting the Supported Document Types</a></li>
<li><a class="reference internal" href="#getting-the-opened-document-names" id="id32">Getting the Opened Document Names</a></li>
</ul>
</li>
<li><a class="reference internal" href="#shortening-the-command" id="id33">Shortening the Command</a></li>
<li><a class="reference internal" href="#using-upx" id="id34">Using UPX</a></li>
<li><a class="reference internal" href="#encrypting-python-bytecode" id="id35">Encrypting Python Bytecode</a></li>
<li><a class="reference internal" href="#supporting-multiple-platforms" id="id36">Supporting Multiple Platforms</a><ul>
<li><a class="reference internal" href="#supporting-multiple-python-environments" id="id37">Supporting Multiple Python Environments</a></li>
<li><a class="reference internal" href="#supporting-multiple-operating-systems" id="id38">Supporting Multiple Operating Systems</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#using-spec-files" id="id39">Using Spec Files</a><ul>
<li><a class="reference internal" href="#spec-file-operation" id="id40">Spec File Operation</a><ul>
<li><a class="reference internal" href="#toc-class-table-of-contents" id="id41">TOC Class (Table of Contents)</a></li>
<li><a class="reference internal" href="#the-tree-class" id="id42">The Tree Class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#adding-files-to-the-bundle" id="id43">Adding Files to the Bundle</a></li>
<li><a class="reference internal" href="#giving-run-time-python-options" id="id44">Giving Run-time Python Options</a></li>
<li><a class="reference internal" href="#id1" id="id45">Encrypting Python Bytecode</a></li>
<li><a class="reference internal" href="#spec-file-options-for-mac-os-x-apps" id="id46">Spec File Options For Mac OS X Apps</a></li>
</ul>
</li>
<li><a class="reference internal" href="#when-things-go-wrong" id="id47">When Things Go Wrong</a><ul>
<li><a class="reference internal" href="#recipes-and-examples-for-specific-problems" id="id48">Recipes and Examples for Specific Problems</a></li>
<li><a class="reference internal" href="#getting-the-latest-version" id="id49">Getting the Latest Version</a></li>
<li><a class="reference internal" href="#finding-out-what-went-wrong" id="id50">Finding out What Went Wrong</a><ul>
<li><a class="reference internal" href="#build-time-messages" id="id51">Build-time Messages</a></li>
<li><a class="reference internal" href="#build-time-python-errors" id="id52">Build-Time Python Errors</a></li>
<li><a class="reference internal" href="#getting-debug-messages" id="id53">Getting Debug Messages</a></li>
<li><a class="reference internal" href="#getting-python-s-verbose-imports" id="id54">Getting Python's Verbose Imports</a></li>
</ul>
</li>
<li><a class="reference internal" href="#helping-pyinstaller-find-modules" id="id55">Helping PyInstaller Find Modules</a><ul>
<li><a class="reference internal" href="#extending-the-path" id="id56">Extending the Path</a></li>
<li><a class="reference internal" href="#listing-hidden-imports" id="id57">Listing Hidden Imports</a></li>
<li><a class="reference internal" href="#extending-a-package-s-path" id="id58">Extending a Package's <tt class="docutils literal">__path__</tt></a></li>
<li><a class="reference internal" href="#changing-runtime-behavior" id="id59">Changing Runtime Behavior</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-topics" id="id60">Advanced Topics</a><ul>
<li><a class="reference internal" href="#the-bootstrap-process-in-detail" id="id61">The Bootstrap Process in Detail</a><ul>
<li><a class="reference internal" href="#bootloader" id="id62">Bootloader</a></li>
<li><a class="reference internal" href="#running-python-code" id="id63">Running Python code</a></li>
<li><a class="reference internal" href="#python-imports-in-a-bundled-app" id="id64">Python imports in a bundled app</a></li>
</ul>
</li>
<li><a class="reference internal" href="#adapting-to-being-frozen" id="id65">Adapting to being &quot;frozen&quot;</a></li>
<li><a class="reference internal" href="#accessing-data-files" id="id66">Accessing Data Files</a></li>
<li><a class="reference internal" href="#capturing-version-data" id="id67">Capturing Version Data</a></li>
<li><a class="reference internal" href="#inspecting-archives" id="id68">Inspecting Archives</a><ul>
<li><a class="reference internal" href="#zlibarchive" id="id69">ZlibArchive</a></li>
<li><a class="reference internal" href="#carchive" id="id70">CArchive</a></li>
<li><a class="reference internal" href="#using-pyi-archive-viewer" id="id71">Using pyi-archive_viewer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#inspecting-executables" id="id72">Inspecting Executables</a></li>
<li><a class="reference internal" href="#multipackage-bundles" id="id73">Multipackage Bundles</a><ul>
<li><a class="reference internal" href="#merge-function" id="id74">MERGE Function</a></li>
<li><a class="reference internal" href="#example-merge-spec-file" id="id75">Example MERGE spec file</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-hook-files" id="id76">Using Hook Files</a></li>
<li><a class="reference internal" href="#hooks-in-detail" id="id77">Hooks in Detail</a></li>
<li><a class="reference internal" href="#building-the-bootloader" id="id78">Building the Bootloader</a><ul>
<li><a class="reference internal" href="#development-tools" id="id79">Development tools</a></li>
<li><a class="reference internal" href="#building" id="id80">Building</a></li>
<li><a class="reference internal" href="#linux-standard-base-lsb-binary" id="id81">Linux Standard Base (LSB) binary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modulefinder-replacement-importtracker" id="id82">Modulefinder Replacement - ImportTracker</a><ul>
<li><a class="reference internal" href="#importtracker" id="id83">ImportTracker</a></li>
<li><a class="reference internal" href="#analyze-one" id="id84"><tt class="docutils literal">analyze_one()</tt></a></li>
<li><a class="reference internal" href="#module-classes" id="id85">Module Classes</a></li>
<li><a class="reference internal" href="#code-scanning" id="id86">code scanning</a></li>
<li><a class="reference internal" href="#hooks" id="id87">Hooks</a></li>
<li><a class="reference internal" href="#warnings" id="id88">Warnings</a></li>
<li><a class="reference internal" href="#cross-reference" id="id89">Cross Reference</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#outdated-features" id="id90">Outdated Features</a><ul>
<li><a class="reference internal" href="#windows-com-server-support" id="id91">Windows COM Server Support</a></li>
<li><a class="reference internal" href="#building-optimized" id="id92">Building Optimized</a></li>
<li><a class="reference internal" href="#iu-py-an-imputil-replacement" id="id93"><tt class="docutils literal">iu.py</tt>: An <em>imputil</em> Replacement</a><ul>
<li><a class="reference internal" href="#importmanager" id="id94"><tt class="docutils literal">ImportManager</tt></a></li>
<li><a class="reference internal" href="#importdirector" id="id95"><tt class="docutils literal">ImportDirector</tt></a></li>
<li><a class="reference internal" href="#pathimportdirector" id="id96"><tt class="docutils literal">PathImportDirector</tt></a></li>
<li><a class="reference internal" href="#owner" id="id97"><tt class="docutils literal">Owner</tt></a></li>
<li><a class="reference internal" href="#packages" id="id98">Packages</a></li>
<li><a class="reference internal" href="#possibilities" id="id99">Possibilities</a></li>
<li><a class="reference internal" href="#compatibility" id="id100">Compatibility</a></li>
<li><a class="reference internal" href="#performance" id="id101">Performance</a></li>
<li><a class="reference internal" href="#limitations" id="id102">Limitations</a></li>
<li><a class="reference internal" href="#iu-usage" id="id103">iu Usage</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="requirements">
<h1><a class="toc-backref" href="#id3">Requirements</a></h1>
<dl class="docutils">
<dt><strong>Windows</strong></dt>
<dd><ul class="first last simple">
<li>Windows XP or newer.</li>
<li><a class="reference external" href="http://sourceforge.net/projects/pywin32/files/">PyWin32</a>
Python extensions for Windows is needed for users of Python 2.6 and later.</li>
</ul>
</dd>
<dt><strong>Mac OS X</strong></dt>
<dd><ul class="first last simple">
<li>Mac OS X 10.4 (Tiger) or newer (Leopard, Snow Leopard, Lion, Mountain Lion).</li>
</ul>
</dd>
<dt><strong>Linux</strong></dt>
<dd><ul class="first last simple">
<li>ldd:
Console application to print the shared libraries required by
each program or shared library. This typically can by found in the
distribution-package <cite>glibc</cite> or <cite>libc-bin</cite>.</li>
<li>objdump:
Console application to display information from object files. This
typically can by found in the distribution-package <cite>binutils</cite>.</li>
</ul>
</dd>
<dt><strong>Solaris</strong></dt>
<dd><ul class="first last simple">
<li>ldd</li>
<li>objdump</li>
</ul>
</dd>
<dt><strong>AIX</strong></dt>
<dd><ul class="first last simple">
<li>AIX 6.1 or newer.
Python executables created using PyInstaller on AIX 6.1 should work
on AIX 5.2/5.3.</li>
<li>ldd</li>
<li>objdump</li>
</ul>
</dd>
<dt><strong>FreeBSD</strong></dt>
<dd><ul class="first last simple">
<li>FreeBSD 9.2 or newer.
Tested with FreeBSD 9.2 amd64, with included gcc (version 4.2.1)</li>
<li>ldd</li>
<li>objdump</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="license">
<h1><a class="toc-backref" href="#id4">License</a></h1>
<p>PyInstaller is distributed under the <a class="reference external" href="https://raw.github.com/pyinstaller/pyinstaller/develop/COPYING.txt">GPL License</a> but it has
an exception such that you can use it to compile commercial products.</p>
<p>In a nutshell, the license is GPL for the source code with the exception that:</p>
<blockquote>
<ol class="arabic simple">
<li>You may use PyInstaller to compile commercial applications out of your
source code.</li>
<li>The resulting binaries generated by PyInstaller from your source code can be
shipped with whatever license you want.</li>
<li>You may modify PyInstaller for your own needs but changes to the
PyInstaller source code fall under the terms of the GPL license.
That is, if you distribute your modifications you must distribute
them under GPL terms.</li>
</ol>
</blockquote>
<p>For updated information or clarification see our
<a class="reference external" href="http://www.pyinstaller.org/wiki/FAQ">FAQ</a> at the <a class="reference external" href="http://www.pyinstaller.org">PyInstaller</a> home page.</p>
</div>
<div class="section" id="how-to-contribute">
<h1><a class="toc-backref" href="#id5">How To Contribute</a></h1>
<p><cite>PyInstaller</cite> is an open-source project that is created and
maintained by volunteers.
At <a class="reference external" href="http://www.pyinstaller.org/">Pyinstaller.org</a> you find links to the mailing list,
IRC channel, and Git repository,
and the important <a class="reference external" href="http://www.pyinstaller.org/wiki/Development/HowtoContribute">How to Contribute</a> link.
Contributions to code and documentation are welcome,
as well as tested hooks for installing other packages.</p>
</div>
<div class="section" id="installing-pyinstaller">
<h1><a class="toc-backref" href="#id6">Installing <cite>PyInstaller</cite></a></h1>
<p>Beginning with version 2.1 <cite>PyInstaller</cite> is a Python package and
is installed like other Python packages.</p>
<div class="section" id="installing-using-pip">
<h2><a class="toc-backref" href="#id7">Installing Using pip</a></h2>
<p>The recommended method for Windows, Linux, or Mac OS
is to use one of the standard
package installers such as  <a class="reference external" href="http://www.pip-installer.org/">pip</a> (or the earlier <a class="reference external" href="http://peak.telecommunity.com/DevCenter/EasyInstall">easy_install</a>).
When you have installed one of these tools
you can download and install <cite>PyInstaller</cite> in one command, for example:</p>
<pre class="literal-block">
pip install pyinstaller
</pre>
<p>and upgrade to a newer version in one command:</p>
<pre class="literal-block">
pip install --upgrade pyinstaller
</pre>
<div class="section" id="installing-in-windows">
<h3><a class="toc-backref" href="#id8">Installing in Windows</a></h3>
<p>For Windows, <a class="reference external" href="http://sourceforge.net/projects/pywin32/files/">PyWin32</a> is a prerequisite.
Follow that link and carefully read the instructions; there
is a different version of PyWin32 for each version of Python.
With this done you can continue to install <tt class="docutils literal">pip</tt> using the
MS-DOS command line.</p>
<p>However it is particularly easy to use <a class="reference external" href="https://sites.google.com/site/pydatalog/python/pip-for-windows">pip-Win</a>,
which sets up both <a class="reference external" href="http://www.pip-installer.org/">pip</a> and <a class="reference external" href="http://www.virtualenv.org/">virtualenv</a> and makes it simple
to install packages and to switch between different Python interpreters.
(For more on the uses of virtualenv, see <a class="reference internal" href="#supporting-multiple-platforms">Supporting Multiple Platforms</a> below.)</p>
<p>When pip-Win is working, enter this command in its Command field
and click Run:</p>
<blockquote>
<tt class="docutils literal">venv <span class="pre">-c</span> <span class="pre">-i</span>&nbsp; <span class="pre">pyi-env-name</span></tt></blockquote>
<p>This creates a new virtual environment rooted at <tt class="docutils literal"><span class="pre">C:\Python\pyi-env-name</span></tt>
and makes it the current environment.
A new command shell
window opens in which you can run commands within this environment.
Enter the command</p>
<blockquote>
<tt class="docutils literal">pip install PyInstaller</tt></blockquote>
<p>Whenever you want to use <cite>PyInstaller</cite>,</p>
<ul class="simple">
<li>Start pip-Win</li>
<li>In the Command field enter <tt class="docutils literal">venv <span class="pre">pyi-env-name</span></tt></li>
<li>Click Run</li>
</ul>
<p>Then you have a command shell window in which commands
execute in that environment.</p>
</div>
</div>
<div class="section" id="installing-from-the-archive">
<h2><a class="toc-backref" href="#id9">Installing from the archive</a></h2>
<p>You can also install <cite>PyInstaller</cite> by downloading the compressed archive
from <a class="reference external" href="https://pypi.python.org/pypi/PyInstaller/">PyPI</a> and expanding the archive.</p>
<p>Inside the archive is a script named <tt class="docutils literal">setup.py</tt>.
Execute <tt class="docutils literal">python setup.py install</tt>
with administrator privilege to install or upgrade <cite>PyInstaller</cite>.</p>
<p>For platforms other than Windows, Linux and Mac OS, you must build a
bootloader program for your platform before installing the Python package.</p>
<ul class="simple">
<li><tt class="docutils literal">cd</tt> into the distribution folder.</li>
<li><tt class="docutils literal">cd bootloader</tt>.</li>
<li>Make a bootloader with: <tt class="docutils literal">python ./waf configure build install</tt>.</li>
</ul>
<p>If this reports an error, read <a class="reference internal" href="#building-the-bootloader">Building the Bootloader</a> below,
then ask for technical help.
It is of no use to continue the installation without a bootloader.
After the bootloader has been created,
you can run <tt class="docutils literal">python setup.py install</tt> with administrator privileges
to complete the installation.</p>
</div>
<div class="section" id="verifying-the-installation">
<h2><a class="toc-backref" href="#id10">Verifying the installation</a></h2>
<p>On all platforms, the command <tt class="docutils literal">pyinstaller</tt> should now exist on the
execution path. To verify this, enter the command</p>
<blockquote>
<tt class="docutils literal">pyinstaller <span class="pre">--version</span></tt></blockquote>
<p>The result should resemble <tt class="docutils literal">2.n</tt> for a released version,
and <tt class="docutils literal"><span class="pre">2.1dev-xxxxxx</span></tt> for a development branch.</p>
<p>If the command is not found, make sure the execution path includes
the proper directory:</p>
<ul class="simple">
<li>Windows: <tt class="docutils literal"><span class="pre">C:\PythonXY\Scripts</span></tt> (where <em>XY</em> stands for the
major and minor Python verysion number, for example <tt class="docutils literal"><span class="pre">C:\Python27\Scripts</span></tt>
for Python 2.7)</li>
<li>Linux: <tt class="docutils literal">/usr/bin/</tt></li>
<li>OS X (using the default Apple-supplied Python) <tt class="docutils literal">/usr/local/bin</tt></li>
<li>OS X (using Python installed by macports) <tt class="docutils literal">/opt/local/bin</tt></li>
</ul>
<p>To display the current path in Windows the command is <tt class="docutils literal">echo %path%</tt>
and in other systems, <tt class="docutils literal">echo $PATH</tt>.</p>
</div>
<div class="section" id="installed-commands">
<h2><a class="toc-backref" href="#id11">Installed commands</a></h2>
<p>The complete installation places these commands on the execution path:</p>
<ul class="simple">
<li><tt class="docutils literal">pyinstaller</tt> is the main command to build a bundled application.
See <a class="reference internal" href="#using-pyinstaller">Using PyInstaller</a>.</li>
<li><tt class="docutils literal"><span class="pre">pyi-makespec</span></tt> is used to create a spec file. See <a class="reference internal" href="#using-spec-files">Using Spec Files</a>.</li>
<li><tt class="docutils literal"><span class="pre">pyi-build</span></tt> is used to execute a spec file that already exists.
See <a class="reference internal" href="#using-spec-files">Using Spec Files</a>.</li>
<li><tt class="docutils literal"><span class="pre">pyi-archive_viewer</span></tt> is used to inspect a bundled application.
See <a class="reference internal" href="#inspecting-archives">Inspecting Archives</a>.</li>
<li><tt class="docutils literal"><span class="pre">pyi-bindepend</span></tt> is used to display dependencies of an executable.
See <a class="reference internal" href="#inspecting-executables">Inspecting Executables</a>.</li>
<li><tt class="docutils literal"><span class="pre">pyi-grab_version</span></tt> is used to extract a version resource from a Windows
executable.  See <a class="reference internal" href="#capturing-version-data">Capturing Version Data</a>.</li>
<li><tt class="docutils literal"><span class="pre">pyi-make_comserver</span></tt> is used to build a Windows COM server.
See <a class="reference internal" href="#windows-com-server-support">Windows COM Server Support</a>.</li>
</ul>
<p>If you do not perform the complete installation (<tt class="docutils literal">setup.py</tt> or
installing via <tt class="docutils literal">pip</tt>), these commands will not exist as commands.
However you can still execute all the functions documented below
by running Python scripts found in the distribution folder.
The equivalent of the <tt class="docutils literal">pyinstaller</tt> command is
<em>pyinstaller-folder</em> <tt class="docutils literal">/pyinstaller.py</tt>.
The other commands are found in <em>pyinstaller-folder</em> <tt class="docutils literal">/cliutils/</tt>
with obvious names (<tt class="docutils literal">makespec.py</tt>, etc.)</p>
</div>
</div>
<div class="section" id="overview-what-pyinstaller-does-and-how-it-does-it">
<h1><a class="toc-backref" href="#id12">Overview: What <cite>PyInstaller</cite> Does and How It Does It</a></h1>
<p>This section covers the basic ideas of <cite>PyInstaller</cite>.
These ideas apply to all platforms.
There are many options, exceptions, and special cases covered under <a class="reference internal" href="#using-pyinstaller">Using PyInstaller</a>.
<cite>PyInstaller</cite> reads a Python script written by you.
First it analyzes your code to discover every other file
your script needs in order to execute.
Then it finds, copies, and collects all those other
files -- including the active Python interpreter! -- and
puts them with
your script in a single folder,
or optionally in a single executable file.</p>
<p>You distribute this folder or file to other people, and they can execute
your program.
As far as your users can tell, your app is self-contained;
they do not need to install any support packages,
or any particular version of Python.
They do not need to have Python installed at all.</p>
<p>The output of  <cite>PyInstaller</cite> is specific to the active operating system
and the active version of Python. To prepare a distribution for a different
OS, or for a dfferent version of Python,
you run <cite>PyInstaller</cite> on that OS, under that version of Python.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Don't assume that your 64-bit based Python will generate
executables that work on 32-bit systems.</p>
</div>
<div class="section" id="analysis-finding-the-files-your-program-needs">
<h2><a class="toc-backref" href="#id13">Analysis: Finding the Files Your Program Needs</a></h2>
<p>What does your script need in order to run, besides a Python interpreter?
To find out, <cite>PyInstaller</cite> looks at all the <tt class="docutils literal">import</tt> statements
in your script.
It finds those Python modules and looks in them for <tt class="docutils literal">import</tt>
statements, and so on recursively, until it has a complete list of Python
modules your
script requires.</p>
<p><cite>PyInstaller</cite> understands the &quot;egg&quot; distribution format often used
for Python packages.
If your script imports a module from an &quot;egg&quot; <cite>PyInstaller</cite> adds
the egg and its dependencies to the set of needed files.</p>
<p><cite>PyInstaller</cite> also knows about the GUI packages
<a class="reference external" href="http://www.qt-project.org">Qt</a> (imported via <a class="reference external" href="http://www.riverbankcomputing.co.uk/software/pyqt/intro">PyQt</a> or <a class="reference external" href="http://qt-project.org/wiki/About-PySide">PySide</a>), <a class="reference external" href="http://www.wxpython.org/">WxPython</a>, <a class="reference external" href="http://wiki.python.org/moin/TkInter">TkInter</a>, <a class="reference external" href="https://www.djangoproject.com/">Django</a>,
and other major packages.</p>
<p>Some Python scripts import modules in ways that <cite>PyInstaller</cite> cannot detect:
for example, by using the <tt class="docutils literal">__import__()</tt> function with variable data,
or manipulating the <tt class="docutils literal">sys.path</tt> value at run time.
If your script requires files that <cite>PyInstaller</cite> does not know about,
you must help it:</p>
<ul class="simple">
<li>You can give additional files on the <cite>PyInstaller</cite> command line.</li>
<li>You can give additional import paths on the command line.</li>
<li>You can edit the <tt class="docutils literal">myscript.spec</tt> file
that <cite>PyInstaller</cite> writes the first time you run it for your script.
In the spec file you can tell <cite>PyInstaller</cite> about code modules
that are unique to your script.</li>
<li>You can write &quot;hook&quot; files that inform <cite>PyInstaller</cite> of hidden imports.
If you &quot;hook&quot; imports for a package that other users might also use,
you can contribute your hook file to <cite>PyInstaller</cite>.</li>
</ul>
<p>If your program depends on access to certain data files,
you can tell <cite>PyInstaller</cite> to include them in the bundle as well.
You do this by modifying the spec file, an advanced topic that is
covered under <a class="reference internal" href="#using-spec-files">Using Spec Files</a>.
In order to locate these files, your program needs to be able to
learn its path at run time in a way that works regardless of
whether or not it is running from a bundle.
This is covered under <a class="reference internal" href="#accessing-data-files">Accessing Data Files</a>.</p>
</div>
<div class="section" id="bundling-to-one-folder">
<h2><a class="toc-backref" href="#id14">Bundling to One Folder</a></h2>
<p>When you apply <cite>PyInstaller</cite> to <tt class="docutils literal">myscript.py</tt> the default
result is a single folder named <tt class="docutils literal">myscript</tt>.
This folder contains all the necessary
support files, and an executable file also named <tt class="docutils literal">myscript</tt>
(<tt class="docutils literal">myscript.exe</tt> in Windows).</p>
<p>You compress the folder
to <tt class="docutils literal">myscript.zip</tt> and transmit it to your users.
They install the program simply by unzipping it.
A user runs your app by
opening the folder and launching the <tt class="docutils literal">myscript</tt> executable inside it.</p>
<p>A small advantage of one-folder mode is that it is easier to debug
a failure in building the app.
You can see exactly what files <cite>PyInstaller</cite> collected.</p>
<p>Another small advantage
is that when you change your code, as long
as it imports <cite>exactly the same set of support files</cite>, you could send out
only the updated <tt class="docutils literal">myscript</tt> executable.
That is typically much smaller
than the entire folder.
(Of course, if you change the script so that it imports more
or different support files, or if the support libraries
are upgraded, you must redistribute the whole bundle.)</p>
<p>A small disadvantage of the one-folder format is that the one folder contains
a large number of files.
Your user must find the <tt class="docutils literal">myscript</tt> executable
in a long list of names or a big array of icons.
Also your user can create
a problem by accidentally dragging files out of the folder.</p>
</div>
<div class="section" id="bundling-to-one-file">
<h2><a class="toc-backref" href="#id15">Bundling to One File</a></h2>
<p>An option of <cite>PyInstaller</cite> is to produce a single executable named
<tt class="docutils literal">myscript</tt> (<tt class="docutils literal">myscript.exe</tt> in Windows).
All the support files needed to run your program are embedded in the one program file.</p>
<p>The advantage of this is that your users get something they understand,
a single executable to launch.
One disadvantage is that any related files
such as README must be distributed separately.
Another is that the single executable is a little slower to start up than
the executable in one folder.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Before bundling your project to one file, make sure it works fine
when bundled to one folder. <a class="reference internal" href="#when-things-go-wrong">When Things Go Wrong</a> it's <em>much</em> easier to
find out what actually went wrong if you bundled to one folder.</p>
</div>
</div>
<div class="section" id="how-the-one-folder-program-works">
<h2><a class="toc-backref" href="#id16">How the One-Folder Program Works</a></h2>
<p>A bundled program always starts execution in the <cite>PyInstaller</cite> bootloader.
This is the heart of the <tt class="docutils literal">myscript</tt> executable in the one folder,
and of the one-file executable.</p>
<p>The <cite>PyInstaller</cite> bootloader is a binary
executable program for the active platform
(Windows, Linux, Mac OS X, etc.).
When the user launches your program, it is the bootloader that runs.
For a one-folder program, the bootloader
creates a temporary Python environment
such that the Python interpreter will find all imported modules and libraries
in the <tt class="docutils literal">myscript</tt> folder.</p>
<p>The bootloader starts a copy of the Python interpreter
to execute your script.
Everything follows normally from there, provided
that all the necessary support files were included.</p>
<p>(This is an overview.
For more detail, see <a class="reference internal" href="#the-bootstrap-process-in-detail">The Bootstrap Process in Detail</a> below.)</p>
</div>
<div class="section" id="how-the-one-file-program-works">
<h2><a class="toc-backref" href="#id17">How the One-File Program Works</a></h2>
<p>For a one-file program, the bootloader first creates a temporary folder
in the appropriate temp-folder location for this OS.
The folder is named <tt class="docutils literal">_MEI</tt><em>xxxxxx</em>, where <em>xxxxxx</em> is a random number.</p>
<p>The one file contains an embedded archive of all the Python
modules used by your script, as well as
compressed copies of any non-Python support files (e.g. <tt class="docutils literal">.so</tt> files).
The bootloader uncompresses the support files and writes copies
into the the temporary folder.
This can take a little time.
That is why a one-file app is a little slower to start
than a one-folder app.</p>
<p>After creating the temporary folder, the bootloader
proceeds exactly as for the one-folder
bundle, in the context of the temporary folder.
When the bundled code terminates,
it deletes the temporary folder.</p>
<p>(Note that in Linux and related systems, it is possible
to mount the <tt class="docutils literal">/tmp</tt> folder with a &quot;no-execution&quot; option.
That option is not compatible with a <cite>PyInstaller</cite>
one-file bundle. It needs to execute code out of <tt class="docutils literal">/tmp</tt>.)</p>
<p>Because the program makes a temporary folder with a unique name,
you can run multiple copies; they won't interfere with each other.
However, running multiple copies is expensive in disk space because nothing is shared.</p>
<p>The <tt class="docutils literal">_MEI</tt><em>xxxxxx</em> folder is not removed if the program crashes
or is killed (kill -9 on Unix, killed by the Task Manager on Windows,
&quot;Force Quit&quot; on Mac OS).
Thus if your app crashes frequently, your users will lose disk space to
multiple <tt class="docutils literal">_MEI</tt><em>xxxxxx</em> temporary folders.</p>
<p>Do <em>not</em> give administrator privileges to a one-file executable
(setuid root in Unix/Linux, &quot;Run this program as an administrator&quot;
property in Windows 7).
There is an unlikely but not impossible way in which a malicious attacker could
corrupt one of the shared libraries in the temp folder
while the bootloader is preparing it.
Distribute a privileged program in one-folder mode instead.</p>
</div>
<div class="section" id="console-or-not">
<h2><a class="toc-backref" href="#id18">Console or not?</a></h2>
<p>By default the bootloader creates a command-line console
(a terminal window in Linux and Mac OS, a command window in Windows).
It gives this window to the Python interpreter for its standard input and output.
Error messages from Python and
print statements in your script will appear in the console window.
If your script reads from standard input, the user can enter data in the window.</p>
<p>An option for Windows and Mac OS is to tell <cite>PyInstaller</cite> to not provide a console window.
The bootloader starts Python with no target for standard output or input.
Do this if your script has a graphical interface for user input and can properly
report its own diagnostics.</p>
</div>
<div class="section" id="hiding-the-source-code">
<h2><a class="toc-backref" href="#id19">Hiding the Source Code</a></h2>
<p>The bundled app does not include any source code.
However, <cite>PyInstaller</cite> bundles compiled Python scripts (<tt class="docutils literal">.pyc</tt> files).
These could in principle be decompiled to reveal the logic of
your code.</p>
<p>If you want to hide your source code more thoroughly, one possible option
is to compile some of your modules with <a class="reference external" href="http://www.cython.org/">Cython</a>.
Using Cython you can convert Python modules into C and compile
the C to machine language.
<cite>PyInstaller</cite> can follow import statements that refer to
Cython C object modules and bundle them.</p>
<p>Additionally, Python bytecode can be obfuscated with AES256 by specifying
an encryption key on PyInstaller's command line. Please note that it is still
very easy to extract the key and get back the original bytecode, but it
should prevent most forms of &quot;occasional&quot; tampering.</p>
</div>
</div>
<div class="section" id="using-pyinstaller">
<h1><a class="toc-backref" href="#id20">Using PyInstaller</a></h1>
<p>The syntax of the <tt class="docutils literal">pyinstaller</tt> command is:</p>
<blockquote>
<tt class="docutils literal">pyinstaller</tt> [<em>options</em>] <em>script</em> [<em>script</em> ...] | <em>specfile</em></blockquote>
<p>In the most simple case,
set the current directory to the location of your program <tt class="docutils literal">myscript.py</tt>
and execute:</p>
<pre class="literal-block">
pyinstaller myscript.py
</pre>
<p><cite>PyInstaller</cite> analyzes <tt class="docutils literal">myscript.py</tt> and:</p>
<ul class="simple">
<li>Writes <tt class="docutils literal">myscript.spec</tt> in the same folder as the script.</li>
<li>Creates a folder <tt class="docutils literal">build</tt> in the same folder as the script if it does not exist.</li>
<li>Writes some log files and working files in the <tt class="docutils literal">build</tt> folder.</li>
<li>Creates a folder <tt class="docutils literal">dist</tt> in the same folder as the script if it does not exist.</li>
<li>Writes the <tt class="docutils literal">myscript</tt> executable folder in the <tt class="docutils literal">dist</tt> folder.</li>
</ul>
<p>In the <tt class="docutils literal">dist</tt> folder you find the bundled app you distribute to your users.</p>
<p>Normally you name one script on the command line.
If you name more, all are analyzed and included in the output.
However, the first script named supplies the name for the
spec file and for the executable folder or file.
Its code is the first to execute at run-time.</p>
<p>For certain uses you may edit the contents of <tt class="docutils literal">myscript.spec</tt>
(described under <a class="reference internal" href="#using-spec-files">Using Spec Files</a>).
After you do this, you name the spec file to <cite>PyInstaller</cite> instead of the script:</p>
<blockquote>
<tt class="docutils literal">pyinstaller myscript.spec</tt></blockquote>
<p>You may give a path to the script or spec file, for example</p>
<blockquote>
<tt class="docutils literal">pyinstaller</tt> <cite>options...</cite> <tt class="docutils literal">~/myproject/source/myscript.py</tt></blockquote>
<p>or, on Windows,</p>
<blockquote>
<tt class="docutils literal">pyinstaller <span class="pre">&quot;C:\Documents</span> and Settings\project\myscript.spec&quot;</tt></blockquote>
<div class="section" id="options">
<h2><a class="toc-backref" href="#id21">Options</a></h2>
<div class="section" id="general-options">
<h3><a class="toc-backref" href="#id22">General Options</a></h3>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-h</span>, <span class="option">--help</span></kbd></td>
<td>show this help message and exit</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-v</span>, <span class="option">--version</span></kbd></td>
<td>Show program version info and exit.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">--distpath=<var>DIR</var></span></kbd></td>
<td>Where to put the bundled app (default: /home/hartmut/p
rojekte/software/pyinstaller/doc/source/dist)</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--workpath=<var>WORKPATH</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Where to put all the temporary work files, .log, .pyz
and etc. (default: /home/hartmut/projekte/software/pyi
nstaller/doc/source/build)</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">-y</span>, <span class="option">--noconfirm</span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Replace output directory (default:
SPECPATH/dist/SPECNAME) without asking for
confirmation</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--upx-dir=<var>UPX_DIR</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Path to UPX utility (default: search the execution
path)</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-a</span>, <span class="option">--ascii</span></kbd></td>
<td>Do not include unicode encoding support (default:
included if available)</td></tr>
<tr><td class="option-group">
<kbd><span class="option">--clean</span></kbd></td>
<td>Clean PyInstaller cache and remove temporary files
before building.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--log-level=<var>LOGLEVEL</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Amount of detail in build-time console messages
(default: INFO, choose one of DEBUG, INFO, WARN,
ERROR, CRITICAL)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="what-to-generate">
<h3><a class="toc-backref" href="#id23">What to generate</a></h3>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-F</span>, <span class="option">--onefile</span></kbd></td>
<td>Create a one-file bundled executable.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-D</span>, <span class="option">--onedir</span></kbd></td>
<td>Create a one-folder bundle containing an executable
(default)</td></tr>
<tr><td class="option-group">
<kbd><span class="option">--specpath=<var>DIR</var></span></kbd></td>
<td>Folder to store the generated spec file (default:
current directory)</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">-n <var>NAME</var></span>, <span class="option">--name=<var>NAME</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Name to assign to the bundled app and spec file
(default: first script's basename)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="what-to-bundle-where-to-search">
<h3><a class="toc-backref" href="#id24">What to bundle, where to search</a></h3>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group" colspan="2">
<kbd><span class="option">-p <var>DIR</var></span>, <span class="option">--paths=<var>DIR</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>A path to search for imports (like using PYTHONPATH).
Multiple paths are allowed, separated by ':', or use
this option multiple times</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--hidden-import=<var>MODULENAME</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Name an import not visible in the code of the
script(s). This option can be used multiple times.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--additional-hooks-dir=<var>HOOKSPATH</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>An additional path to search for hooks. This option
can be used multiple times.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--runtime-hook=<var>RUNTIME_HOOKS</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Path to a custom runtime hook file. A runtime hook is
code that is bundled with the executable and is
executed before any other code or module to set up
special features of the runtime environment. This
option can be used multiple times.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--exclude-module=<var>EXCLUDES</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Optional module or package (his Python names,not path
names) that will be ignored (as thoughit was not
found).This option can be used multiple times.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">--key=<var>KEY</var></span></kbd></td>
<td>The key used to encrypt Python bytecode.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="how-to-generate">
<h3><a class="toc-backref" href="#id25">How to generate</a></h3>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-d</span>, <span class="option">--debug</span></kbd></td>
<td>Tell the bootloader to issue progress messages while
initializing and starting the bundled app. Used to
diagnose problems with missing imports.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-s</span>, <span class="option">--strip</span></kbd></td>
<td>Apply a symbol-table strip to the executable and
shared libs (not recommended for Windows)</td></tr>
<tr><td class="option-group">
<kbd><span class="option">--noupx</span></kbd></td>
<td>Do not use UPX even if it is available (works
differently between Windows and *nix)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="windows-and-mac-os-x-specific-options">
<h3><a class="toc-backref" href="#id26">Windows and Mac OS X specific options</a></h3>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group" colspan="2">
<kbd><span class="option">-c</span>, <span class="option">--console</span>, <span class="option">--nowindowed</span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Open a console window for standard i/o (default)</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">-w</span>, <span class="option">--windowed</span>, <span class="option">--noconsole</span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Windows and Mac OS X: do not provide a console window
for standard i/o. On Mac OS X this also triggers
building an OS X .app bundle.This option is ignored in
*NIX systems.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">-i <var>&lt;FILE.ico or FILE.exe,ID or FILE.icns&gt;</var></span>, <span class="option">--icon=<var>&lt;FILE.ico or FILE.exe,ID or FILE.icns&gt;</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>FILE.ico: apply that icon to a Windows executable.
FILE.exe,ID, extract the icon with ID from an exe.
FILE.icns: apply the icon to the .app bundle on Mac OS
X</td></tr>
</tbody>
</table>
</div>
<div class="section" id="windows-specific-options">
<h3><a class="toc-backref" href="#id27">Windows specific options</a></h3>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--version-file=<var>FILE</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>add a version resource from FILE to the exe</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">-m <var>&lt;FILE or XML&gt;</var></span>, <span class="option">--manifest=<var>&lt;FILE or XML&gt;</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>add manifest FILE or XML to the exe</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">-r <var>&lt;FILE[,TYPE[,NAME[,LANGUAGE]]]&gt;</var></span>, <span class="option">--resource=<var>&lt;FILE[,TYPE[,NAME[,LANGUAGE]]]&gt;</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Add or update a resource of the given type, name and
language from FILE to a Windows executable. FILE can
be a data file or an exe/dll. For data files, at least
TYPE and NAME must be specified. LANGUAGE defaults to
0 or may be specified as wildcard * to update all
resources of the given TYPE and NAME. For exe/dll
files, all resources from FILE will be added/updated
to the final executable if TYPE, NAME and LANGUAGE are
omitted or specified as wildcard *.This option can be
used multiple times.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">--uac-admin</span></kbd></td>
<td>Using this option creates a Manifest which will
request elevation upon application restart.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">--uac-uiaccess</span></kbd></td>
<td>Using this option allows an elevated application to
work with Remote Desktop.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="mac-os-x-specific-options">
<h3><a class="toc-backref" href="#id28">Mac OS X specific options</a></h3>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--osx-bundle-identifier=<var>BUNDLE_IDENTIFIER</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Mac OS X .app bundle identifier is used as the default
unique program name for code signing purposes. The
usual form is a hierarchical name in reverse DNS
notation. For example:
com.mycompany.department.appname (default: first
script's basename)</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="building-mac-os-x-app-bundles">
<h2><a class="toc-backref" href="#id29">Building Mac OS X App Bundles</a></h2>
<p>If you specify only <tt class="docutils literal"><span class="pre">--onefile</span></tt> under Mac OS X, the output
in <tt class="docutils literal">dist</tt> is a UNIX executable
<tt class="docutils literal">myscript</tt>.
It can be executed from a Terminal command line.
Standard input and output work as normal through the Terminal window.</p>
<p>If you specify <tt class="docutils literal"><span class="pre">--windowed</span></tt>, the <tt class="docutils literal">dist</tt> folder contains
two outputs: the UNIX executable <tt class="docutils literal">myscript</tt>
and also an OS X application named <tt class="docutils literal">myscript.app</tt>.</p>
<p>As you probably know, an application is a special type of folder.
The one built by <cite>PyInstaller</cite> contains a folder always named <tt class="docutils literal">Contents</tt>.
It contains:</p>
<blockquote>
<ul class="simple">
<li>A folder <tt class="docutils literal">Frameworks</tt> which is empty.</li>
<li>A folder <tt class="docutils literal">MacOS</tt> that contains a copy of the same <tt class="docutils literal">myscript</tt> UNIX executable.</li>
<li>A folder <tt class="docutils literal">Resources</tt> that contains an icon file <tt class="docutils literal"><span class="pre">icon-windowed.icns</span></tt>.</li>
<li>A file <tt class="docutils literal">Info.plist</tt> that describes the app.</li>
</ul>
</blockquote>
<p><tt class="docutils literal">Info.plist</tt> is an <a class="reference external" href="https://developer.apple.com/library/mac/#documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigFiles.html">Info Property List</a> XML file (or &quot;plist&quot;).
Its contents tell Mac OS X about your application.
You can inspect and edit a plist  with the Property List Editor
that is part of XCode.</p>
<div class="section" id="setting-a-custom-icon">
<h3><a class="toc-backref" href="#id30">Setting a Custom Icon</a></h3>
<p>The minimal plist provided by <cite>PyInstaller</cite> designates the icon file for the app
as the  <tt class="docutils literal"><span class="pre">icon-windowed.icns</span></tt> file in <tt class="docutils literal">Resources</tt>.
This is the <cite>PyInstaller</cite> logo in icns format.
For now you can apply your own icon after the app is built in several ways:</p>
<ul class="simple">
<li>Prepare another <tt class="docutils literal">.icns</tt> file with your own graphic,
save it as <tt class="docutils literal"><span class="pre">icon-windowed.icns</span></tt> replacing the default one
in <tt class="docutils literal">Resources</tt>.</li>
<li>Prepare an <tt class="docutils literal">.icns</tt> file with your own graphic,
place it in <tt class="docutils literal">Resources</tt> and edit the  <tt class="docutils literal">Info.plist</tt> to name it.</li>
<li>Prepare an <tt class="docutils literal">.icns</tt> file with your own graphic;
open in it Preview.app; select-all and copy;
in the Finder, Get Info on your app;
click the icon in the info display and paste.</li>
</ul>
<p>The following programs are capable of creating <tt class="docutils literal">.icns</tt> files from JPEG or PNG images:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.lemkesoft.de/en/products/graphic-converter/">GraphicConverter</a> ($$)</li>
<li><a class="reference external" href="https://bitbucket.org/mkae/makeicns">makeicns</a> (MIT License)</li>
<li><a class="reference external" href="http://icns.sourceforge.net/">png2icns</a> (GPL)</li>
</ul>
</div>
<div class="section" id="setting-the-supported-document-types">
<h3><a class="toc-backref" href="#id31">Setting the Supported Document Types</a></h3>
<p>You can also edit the <tt class="docutils literal">Info.plist</tt> file to tell the Mac OS X
Launcher what document types your application supports.
Refer to the Mac OS developer documentation for these keywords.</p>
</div>
<div class="section" id="getting-the-opened-document-names">
<h3><a class="toc-backref" href="#id32">Getting the Opened Document Names</a></h3>
<p>When a user double-clicks a document of a type your application
supports, or when a user drags a document icon and drops it
on your application's icon, Mac OS X launches your application
and provides the name(s) of the opened document(s) in the
form of an OpenDocument AppleEvent.
This AppleEvent is received by the bootloader
before your code has started executing.</p>
<p>The bootloader gets the names of opened documents from
the OpenDocument event and encodes them into the <tt class="docutils literal">argv</tt>
string before starting your code.
Thus your code can query <tt class="docutils literal">sys.argv</tt> to get the names
of documents that should be opened at startup.</p>
<p>OpenDocument is the only AppleEvent the bootloader handles.
If you want to handle other events, or events that
are delivered after the program has launched, you must
set up the appropriate handlers.</p>
</div>
</div>
<div class="section" id="shortening-the-command">
<h2><a class="toc-backref" href="#id33">Shortening the Command</a></h2>
<p>Because of its numerous options, a full <tt class="docutils literal">pyinstaller</tt> command
can become very long.
You will run the same command again and again as you develop
your script.
You can put the command in a shell script or batch file,
using line continuations to make it readable.
For example, in Linux:</p>
<pre class="literal-block">
pyinstaller --noconfirm --log-level=WARN \
    --onefile --nowindow \
    --hidden-import=secret1 \
    --hidden-import=secret2 \
    --upx-dir=/usr/local/share/ \
    myscript.spec
</pre>
<p>Or in Windows, use the little-known BAT file line continuation:</p>
<pre class="literal-block">
pyinstaller --noconfirm --log-level=WARN ^
    --onefile --nowindow ^
    --hidden-import=secret1 ^
    --hidden-import=secret2 ^
    --icon-file=..\MLNMFLCN.ICO ^
    myscript.spec
</pre>
</div>
<div class="section" id="using-upx">
<h2><a class="toc-backref" href="#id34">Using UPX</a></h2>
<p><a class="reference external" href="http://upx.sourceforge.net/">UPX</a> is a free utility available for most operating systems.
UPX compresses executable files and libraries, making them smaller,
sometimes much smaller.
UPX is available for most operating systems and can compress
a large number of executable file formats.
See the <a class="reference external" href="http://upx.sourceforge.net/">UPX</a> home page for downloads, and for the list of
supported executable formats.
As of May 2013, the only major absence is 64-bit binaries for
Windows and Mac OS X.
UPX has no effect on these.</p>
<p>A compressed executable program is wrapped in UPX
startup code that dynamically decompresses the program
when the program is launched.
After it has been decompressed, the program runs normally.
In the case of a <cite>PyInstaller</cite> one-file executable that has
been UPX-compressed, the full execution sequence is:</p>
<ul class="simple">
<li>The compressed program start up in the UPX decompressor code.</li>
<li>After decompression, the program executes the <cite>PyInstaller</cite> bootloader,
which creates a temporary environment for Python.</li>
<li>The Python interpreter executes your script.</li>
</ul>
<p><cite>PyInstaller</cite> looks for UPX on the execution path
or the path specified with the <tt class="docutils literal"><span class="pre">--upx-dir</span></tt> option.
If UPX exists, <cite>PyInstaller</cite> applies it to the final executable,
unless the <tt class="docutils literal"><span class="pre">--noupx</span></tt> option was given.
UPX has been used with <cite>PyInstaller</cite> output often, usually with no problems.</p>
</div>
<div class="section" id="encrypting-python-bytecode">
<h2><a class="toc-backref" href="#id35">Encrypting Python Bytecode</a></h2>
<p>Python bytecode can be encrypted by specifying the '--key' argument on
the command line. For this to work, you will need PyCrypto 2.4 (or later) to be
installed on the system where the package is built.</p>
</div>
<div class="section" id="supporting-multiple-platforms">
<h2><a class="toc-backref" href="#id36">Supporting Multiple Platforms</a></h2>
<p>If you distribute your application for only one combination of OS and Python,
just install <cite>PyInstaller</cite> like any other package and use it in your
normal development setup.</p>
<div class="section" id="supporting-multiple-python-environments">
<h3><a class="toc-backref" href="#id37">Supporting Multiple Python Environments</a></h3>
<p>When you need to bundle your application within one OS
but for different versions of Python and support libraries -- for example,
a Python 3 version and a Python 2.7 version;
or a supported version that uses Qt4 and a development version that uses Qt5 --
we recommend you use <a class="reference external" href="http://www.virtualenv.org/">virtualenv</a>.
With virtualenv you can maintain different combinations of Python
and installed packages, and switch from one combination to another easily.</p>
<ul class="simple">
<li>Use virtualenv to create as many different development environments as you need,
each with its own combination of Python and installed packages.</li>
<li>Install <cite>PyInstaller</cite> in each environment.</li>
<li>Use <cite>PyInstaller</cite> to build your application in each environment.</li>
</ul>
<p>Note that when using virtualenv, the path to the <cite>PyInstaller</cite> commands is:</p>
<ul class="simple">
<li>Windows: ENV_ROOT\Scripts</li>
<li>Others:  ENV_ROOT/bin</li>
</ul>
<p>Under Windows, the <a class="reference external" href="https://sites.google.com/site/pydatalog/python/pip-for-windows">pip-Win</a> package installs virtualenv and makes it
especially easy to set up different environments and switch between them.
Under Linux and Mac OS, you switch environments at the command line.</p>
</div>
<div class="section" id="supporting-multiple-operating-systems">
<h3><a class="toc-backref" href="#id38">Supporting Multiple Operating Systems</a></h3>
<p>If you need to distribute your application for more than one OS,
for example both Windows and Mac OS X, you must install <cite>PyInstaller</cite>
on each platform and bundle your app separately on each.</p>
<p>You can do this from a single machine using virtualization.
The free <a class="reference external" href="https://www.virtualbox.org">virtualBox</a> or the paid <a class="reference external" href="http://www.vmware.com/solutions/desktop/">VMWare</a> and <a class="reference external" href="http://www.parallels.com/">Parallels</a>
allow you to run another complete operating system as a &quot;guest&quot;.
You set up a virtual machine for each &quot;guest&quot; OS.
In it you install
Python, the support packages your application needs, and PyInstaller.</p>
<p>The <a class="reference external" href="https://www.dropbox.com/home">Dropbox</a> system is useful with virtual machines.
Install a Dropbox client in each virtual machine, all linked to your Dropbox account.
Keep a single copy of your script(s) in a Dropbox folder.
Then on any virtual machine you can run <cite>PyInstaller</cite> thus:</p>
<pre class="literal-block">
cd ~/Dropbox/project_folder/src # Linux, Mac -- Windows similar
pyinstaller --workpath=path-to-local-temp-folder  \
            --distpath=path-to-local-dist-folder  \
            ...other options as required...       \
            ./myscript.py
</pre>
<p>Your bundled app is in <em>path-to-local-dist-folder</em> on the
virtual machine's local disk.
After testing it, you can compress the app to a zip file and copy it to
the <tt class="docutils literal">Public</tt> folder of your Dropbox.
Your users can download it from there.
(Pro tip: Do not shut down the virtual machine until
Dropbox has completely uploaded the .zip to the cloud.)</p>
<p>It is claimed to be possible to cross-develop for Windows under Linux
using the free <a class="reference external" href="http://www.winehq.org/">Wine</a> environment.
Further details are needed, see <a class="reference external" href="http://www.pyinstaller.org/wiki/Development/HowtoContribute">How to Contribute</a>.</p>
</div>
</div>
</div>
<div class="section" id="using-spec-files">
<h1><a class="toc-backref" href="#id39">Using Spec Files</a></h1>
<p>The spec (specification) file tells <cite>PyInstaller</cite> how to process your script.
When you name a script (or scripts) to the <tt class="docutils literal">pyinstaller</tt> command,
the first thing it does is to build a spec file <em>name</em>.spec.
The spec file encodes the script names and most of the options
you give to the <tt class="docutils literal">pyinstaller</tt> command.</p>
<p>For many uses of <cite>PyInstaller</cite> you do not need to examine or modify the spec file.
Editing the spec file was once a common way to help <cite>PyInstaller</cite>
find all the parts of a program, but this is now less common.
It is usually enough to
give all the needed information (such as hidden imports)
as option values to the <tt class="docutils literal">pyinstaller</tt> command and let it run.</p>
<p>There are three cases where it may be useful to modify the spec file:</p>
<ul class="simple">
<li>When you want to bundle data files with the app.</li>
<li>When you want to add Python run-time options to the executable.</li>
<li>When you want to create a multiprogram bundle with merged common modules.</li>
</ul>
<p>These uses are covered in topics below.</p>
<p>You can create a spec file using this command:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">pyi-makespec</span></tt> <em>options</em> <em>script</em> [<em>script</em> ...]</blockquote>
<p>The <em>options</em> are the same options documented above
for the <tt class="docutils literal">pyinstaller</tt> command.
This command creates the <em>name</em>.spec file but does not
go on to build the executable.</p>
<p>After you have created a spec file and modified it as necessary,
you can build your application from it in either of two ways:</p>
<blockquote>
<tt class="docutils literal">pyinstaller</tt> <em>specfile</em></blockquote>
<p>or</p>
<blockquote>
<tt class="docutils literal"><span class="pre">pyi-build</span></tt> <em>specfile</em></blockquote>
<p>The latter executes the part of <tt class="docutils literal">pyinstaller</tt> that follows creation of a spec file.</p>
<p>When you create a spec file, many command options are written into the spec file.
When you build from a spec file, those options cannot be changed.
If they are given on the command line they are ignored and
replaced by the options in the spec file.
Only the following command-line options have an effect when building from a spec file:</p>
<ul class="simple">
<li>--upx-dir=</li>
<li>--distpath=</li>
<li>--workpath=</li>
<li>--noconfirm</li>
<li>--ascii</li>
</ul>
<div class="section" id="spec-file-operation">
<h2><a class="toc-backref" href="#id40">Spec File Operation</a></h2>
<p>After <cite>PyInstaller</cite> creates a spec file,
or opens a spec file when one is given instead of a script,
the <tt class="docutils literal">pyinstaller</tt> command <em>executes the spec file as code</em>.
This is important to understand: the spec file contents are
the central part of the code executed by <cite>PyInstaller</cite>.
Your bundled application is created by the execution of the spec file.</p>
<p>The statements in a spec file create objects from classes that are defined in the
<cite>PyInstaller</cite> module <tt class="docutils literal">build.py</tt>.
Here is an unrealistically simplified spec file for one-folder mode:</p>
<pre class="literal-block">
a = Analysis(['myscript.py'])
pyz = PYZ(a.pure)
exe = EXE(a.scripts, pyz, name=&quot;myscript&quot;, exclude_binaries=1)
dist = COLLECT(exe, a.binaries, name=&quot;dist&quot;)
</pre>
<p>If you compare an actual spec file you will find about the same statements,
but differently formatted and with more arguments.
The statements do the following:</p>
<ul class="simple">
<li>A new instance of class <tt class="docutils literal">Analysis</tt> takes a list of script names as input.
The resulting object (here named <tt class="docutils literal">a</tt>) contains three lists,
held in object properties named<ul>
<li><tt class="docutils literal">scripts</tt>: the python scripts named on the command line;</li>
<li><tt class="docutils literal">pure</tt>: pure python modules needed by the scripts;</li>
<li><tt class="docutils literal">binaries</tt>: non-python modules needed by the scripts.</li>
</ul>
</li>
<li>An instance of <tt class="docutils literal">PYZ</tt> (a <tt class="docutils literal">.pyz</tt> archive, described
under <a class="reference internal" href="#inspecting-archives">Inspecting Archives</a> below) is built to contain the modules
listed in <tt class="docutils literal">a.pure</tt>.</li>
<li>An instance of <tt class="docutils literal">EXE</tt> is built from the analyzed scripts and the <tt class="docutils literal">PYZ</tt>
archive. This object contains what will be the executable file <tt class="docutils literal">myscript</tt>.</li>
<li>An instance of <tt class="docutils literal">COLLECT</tt> creates the output folder.</li>
</ul>
<p>In one-file mode, there is no call to <tt class="docutils literal">COLLECT</tt>, and the
<tt class="docutils literal">EXE</tt> instance receives all of the scripts, modules and binaries.</p>
<p>In order to read or modify a spec file you must understand some of
the classes it uses.
However, the class definitions and the exact contents of the spec
file might change in future releases.
For this reason, the following
contains only the most useful and reliable detail.
Some further details are under Advanced Topics below;
and you can find the complete definition of these classes in the module <tt class="docutils literal">build.py</tt>.</p>
<div class="section" id="toc-class-table-of-contents">
<h3><a class="toc-backref" href="#id41">TOC Class (Table of Contents)</a></h3>
<p>The <tt class="docutils literal">TOC</tt> (Table Of Contents) class is used by all of the target classes.
For example, the <tt class="docutils literal">scripts</tt> member of an Analysis object is a TOC
containing a list of scripts;
the <tt class="docutils literal">pure</tt> member is a TOC with a list of modules, and so on.</p>
<p>Basically a <tt class="docutils literal">TOC</tt> object contains a list of tuples of the form</p>
<blockquote>
<tt class="docutils literal">(</tt><em>name</em><tt class="docutils literal">,</tt><em>path</em><tt class="docutils literal">,</tt><em>typecode</em><tt class="docutils literal">)</tt></blockquote>
<p>In fact, it acts as an ordered set of tuples; that is, it contains no duplicates
(where uniqueness is based on the <em>name</em> element of each tuple).
Within this constraint, a TOC preserves the order of tuples added to it.</p>
<p>A TOC behaves like a list object and supports the same methods (appending, indexing, etc).
A TOC also supports taking differences and intersections like a set.
For these operations a simple list of tuples can be used as one argument.
This makes excluding modules quite easy.
For example,</p>
<blockquote>
<tt class="docutils literal">a.binaries - <span class="pre">[('badmodule',</span> None, None)]</tt></blockquote>
<p>is an expression that yields a TOC from which any tuple named <tt class="docutils literal">badmodule</tt>
has been removed.</p>
<p>The right-hand argument to the subtraction operator
is a list that contains one tuple
in which <em>name</em> is <tt class="docutils literal">badmodule</tt> and the <em>path</em> and <em>typecode</em> elements
are <tt class="docutils literal">None</tt>.
(Because set membership is based on the <em>name</em> element of a tuple only,
it is not necessary to give accurate <em>path</em> and <em>typecode</em> elements when subtracting.)
So, if you modify this line in a one-folder spec file:</p>
<pre class="literal-block">
dist = COLLECT(..., a.binaries - [('badmodule', None, None)], ...)
</pre>
<p>or this line in a one-file spec:</p>
<pre class="literal-block">
exe = EXE(..., a.binaries - [('badmodule', None, None)], ...)
</pre>
<p>you remove <tt class="docutils literal">badmodule</tt> from the output executable.</p>
<p>In order to add files to a TOC, you need to know the <em>typecode</em> values
and their related <em>path</em> values.
A <em>typecode</em> is a one-word string.
<cite>PyInstaller</cite> uses a number of <em>typecode</em> values internally,
but for the normal case you need to know only three:</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="33%" />
<col width="20%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><strong>typecode</strong></th>
<th class="head"><strong>description</strong></th>
<th class="head"><strong>name</strong></th>
<th class="head"><strong>path</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr><td>'BINARY'</td>
<td>A shared library.</td>
<td>Run-time name.</td>
<td>Full path name in build.</td>
</tr>
<tr><td>'DATA'</td>
<td>Arbitrary files.</td>
<td>Run-time name.</td>
<td>Full path name in build.</td>
</tr>
<tr><td>'OPTION'</td>
<td>A Python run-time option.</td>
<td>Option code</td>
<td>ignored.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="the-tree-class">
<h3><a class="toc-backref" href="#id42">The Tree Class</a></h3>
<p>The Tree class is a way of creating a TOC that describes some or all of the
files within a directory:</p>
<blockquote>
<tt class="docutils literal">Tree(</tt><em>root</em><tt class="docutils literal">, prefix=</tt><em>run-time-folder</em><tt class="docutils literal">, excludes=</tt><em>match</em><tt class="docutils literal">)</tt></blockquote>
<ul class="simple">
<li>The <em>root</em> argument is a path string to a directory.
It may be absolute or relative to the build directory.</li>
<li>The <em>prefix</em> argument, if given, is a name for a subfolder
within the run-time folder to contain the tree files.
If you omit <em>prefix</em> or give <tt class="docutils literal">None</tt>,
the tree files will be at
the top level of the run-time folder.</li>
<li>The <em>excludes</em> argument, if given, is a list of one or more
strings that match files in the <em>root</em> that should be omitted from the Tree.
An item in the list can be either:<ul>
<li>a name, which causes files or folders with this basename to be excluded</li>
<li><tt class="docutils literal">*.ext</tt>, which causes files with this extension to be excluded</li>
</ul>
</li>
</ul>
<p>For example:</p>
<pre class="literal-block">
extra_tree = Tree('../src/extras', prefix='extras', excludes=['tmp'])
</pre>
<p>This creates <tt class="docutils literal">extra_tree</tt> as a TOC object that lists
all files from the relative path <tt class="docutils literal"><span class="pre">../src/extras</span></tt>,
omitting those that have the basename (or are in a folder named) <tt class="docutils literal">tmp</tt>.</p>
<p>Each tuple in this TOC has:</p>
<ul class="simple">
<li>A <em>typecode</em> of <tt class="docutils literal">DATA</tt>,</li>
<li>A <em>path</em> consisting of a complete, absolute path to one file in the <em>root</em> folder,</li>
<li>A <em>name</em> consisting of the filename of this file, or,
if you specify a <em>prefix</em>, the <em>name</em> is <em>prefix</em><tt class="docutils literal">/</tt><em>filename</em>.</li>
</ul>
</div>
</div>
<div class="section" id="adding-files-to-the-bundle">
<h2><a class="toc-backref" href="#id43">Adding Files to the Bundle</a></h2>
<p>To add files to the bundle, you insert descriptions of the files
into the argument list of the <tt class="docutils literal">COLLECT</tt> object for a one-folder bundle,
or to the argument list of the <tt class="docutils literal">EXE</tt> object for a one-file bundle.
You can add files as single TOC-style tuples,
or you can add an entire Tree object by name.</p>
<p>To add a single README file at the top level of a one-folder bundle,
add a single TOC item describing it to the argument list of COLLECT or EXE:</p>
<pre class="literal-block">
collect = COLLECT(a.binaries +
          [('README', '/my/project/readme', 'DATA')], ...)
</pre>
<p>This appends the README tuple to the <tt class="docutils literal">a.binaries</tt> TOC.
(You can use a list of one or more tuples in place of a TOC object in most cases).</p>
<p>The COLLECT and EXE classes take a variable-length list of arguments,
so it is possible to just append a list of one tuple to the argument list:</p>
<pre class="literal-block">
exe = EXE(a.scripts, a.binaries, ...
          [('README', '/my/project/readme', 'DATA')])
</pre>
<p>To add a folder of files, prepare a Tree for that folder:</p>
<pre class="literal-block">
# Include all spellcheck dictionary files, as a folder named dict
dict_tree = Tree('../../aspell/dict', prefix = 'dict')
</pre>
<p>You could for convenience add single files to that Tree:</p>
<pre class="literal-block">
# add README to the Tree TOC for convenience
dict_tree += [('README', '/my/project/readme', 'DATA')]
</pre>
<p>Then simply mention the Tree at any point in the argument list for COLLECT or EXE:</p>
<pre class="literal-block">
collect = COLLECT(dict_tree, a.binaries,...)
</pre>
<p>The topic <a class="reference internal" href="#accessing-data-files">Accessing Data Files</a> describes how to find these files at run-time.</p>
</div>
<div class="section" id="giving-run-time-python-options">
<h2><a class="toc-backref" href="#id44">Giving Run-time Python Options</a></h2>
<p>You can pass a run-time option to the Python interpreter
by adding a tuple to the creation of the EXE object.
The <em>typecode</em> element of the tuple is <tt class="docutils literal">'OPTION'</tt>.
The <em>name</em> element of the tuple is the option code as it would appear on a python command line.
The <em>path</em> element is ignored.
The options the executables understand are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="13%" />
<col width="18%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><strong>Option</strong></th>
<th class="head"><strong>Description</strong></th>
<th class="head"><strong>Example</strong></th>
<th class="head"><strong>Notes</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr><td>v</td>
<td>Verbose imports</td>
<td>('v', None, 'OPTION')</td>
<td>Same as Python -v ...</td>
</tr>
<tr><td>u</td>
<td>Unbuffered stdio</td>
<td>('u', None, 'OPTION')</td>
<td>Same as Python -u ...</td>
</tr>
<tr><td>W spec</td>
<td>Warning option</td>
<td>('W ignore', None, 'OPTION')</td>
<td>Python 2.1+ only.</td>
</tr>
<tr><td>s</td>
<td>Use site.py</td>
<td>('s', None, 'OPTION')</td>
<td>The opposite of Python's -S flag. Note that site.py must be in the executable's directory to be used.</td>
</tr>
</tbody>
</table>
<p>For example:</p>
<pre class="literal-block">
exe = EXE(a.scripts, pyz,
          [('v', None, 'OPTION'),('W ignore', None, 'OPTION')],
          name=&quot;myapp.exe&quot;, exclude_binaries=1)
</pre>
<p>In this example, you have inserted a list of two tuples into the EXE call.</p>
</div>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id45">Encrypting Python Bytecode</a></h2>
<p>In order to have your bytecode obfuscated, you need to load and initialize a
<em>block cipher</em> object with a key. You must then pass this object as the
<tt class="docutils literal">cipher</tt> keyword argument to both the <tt class="docutils literal">Analysis</tt> and <tt class="docutils literal">PYZ</tt> objects
so that the former can pull the required dependencies and generate the key
file loaded at bootstrap time, while the latter can use it to encrypt
Python modules at build time.</p>
<p>A complete example:</p>
<pre class="literal-block">
from PyInstaller.loader import pyi_crypto

block_cipher = pyi_crypto.PyiBlockCipher(key='test_key')
a = Analysis(['test_onefile_crypto.py'], cipher=block_cipher)
pyz = PYZ(a.pure, cipher=block_cipher)
exe = EXE(pyz,
          a.scripts,
          a.binaries,
          a.zipfiles,
          a.datas,
          name='test_onefile_crypto')
</pre>
</div>
<div class="section" id="spec-file-options-for-mac-os-x-apps">
<h2><a class="toc-backref" href="#id46">Spec File Options For Mac OS X Apps</a></h2>
<p>If you want to create <tt class="docutils literal">.app</tt> file, create an instance of <tt class="docutils literal">BUNDLE</tt>. You can specify the version number and icon file, add or overwrite default settings in Info.plist. For example, when you use PyQt5, set NSHighResolutionCapable to True to let your app also work in retina screen:</p>
<pre class="literal-block">
exe = EXE(pyz, a.scripts, exclude_binaries=True, name='example',
          debug=False, strip=None, upx=True, console=False )
bundle = BUNDLE(exe, a.binaries, a.zipfiles, a.datas,
               info_plist={
                 'NSHighResolutionCapable': 'True'
               },
               version='0.0.1', icon='example.icns', name='example.app')
</pre>
</div>
</div>
<div class="section" id="when-things-go-wrong">
<h1><a class="toc-backref" href="#id47">When Things Go Wrong</a></h1>
<div class="section" id="recipes-and-examples-for-specific-problems">
<h2><a class="toc-backref" href="#id48">Recipes and Examples for Specific Problems</a></h2>
<p>Code examples for some advanced uses and some common
problems are available on our <a class="reference external" href="http://www.pyinstaller.org/wiki/Recipe">Recipe</a> web-page.
Some of the recipes there include:</p>
<ul class="simple">
<li>A more sophisticated way of collecting data files
than the one shown above (<a class="reference internal" href="#adding-files-to-the-bundle">Adding Files to the Bundle</a>).</li>
<li>A use of a run-time hook to set the Qt API level.</li>
<li>A workaround for a multiprocessing constraint under Windows.</li>
</ul>
<p>and others. Please feel free to contribute more recipes!</p>
</div>
<div class="section" id="getting-the-latest-version">
<h2><a class="toc-backref" href="#id49">Getting the Latest Version</a></h2>
<p>If you have some reason to think you have found a bug in <cite>PyInstaller</cite>
you can try downloading the latest development version.
This version might have fixes or features that are not yet at <a class="reference external" href="https://pypi.python.org/pypi/PyInstaller/">PyPI</a>.
Links to download the latest stable version and the latest development
version are at <a class="reference external" href="http://www.pyinstaller.org/">PyInstaller.org</a>.</p>
<p>If you have <a class="reference external" href="http://git-scm.com/downloads">Git</a> installed on your development system,
you can use it together with pip
to install the latest version of <cite>PyInstaller</cite> directly:</p>
<pre class="literal-block">
pip install -e git://github.com/pyinstaller/pyinstaller.git#egg=PyInstaller
</pre>
</div>
<div class="section" id="finding-out-what-went-wrong">
<h2><a class="toc-backref" href="#id50">Finding out What Went Wrong</a></h2>
<div class="section" id="build-time-messages">
<h3><a class="toc-backref" href="#id51">Build-time Messages</a></h3>
<p>When an <tt class="docutils literal">Analysis</tt> step runs, it produces error and warning messages.
These display after the command line if the <tt class="docutils literal"><span class="pre">--log-level</span></tt> option allows it.
Analysis also puts messages in a warnings file
named <tt class="docutils literal"><span class="pre">warn&lt;name&gt;.txt</span></tt> in the spec file's directory.</p>
<p>An error message appears if Analysis detects an unconditional import
and the module it names cannot be found.
An unconditional import is one that appears at the top level of the script,
so it is certain to be executed.</p>
<p>A warning is given if the module named in an import cannot be found,
but the import itself is conditional.
An import is conditional when it appears in a function definition
or in an <tt class="docutils literal">if</tt> statement.
There is a reasonable chance that such an import will not be executed,
so it will not matter that the module cannot be found.</p>
<p>For example, <tt class="docutils literal">os.py</tt> (which is cross-platform) works by figuring out what
platform it is on, then importing and rebinding names from the appropriate
platform-specific module.
If your script imports <tt class="docutils literal">os</tt> or <tt class="docutils literal">os.path</tt>, the warning file
will have lines like:</p>
<pre class="literal-block">
WARNING: no module named dos (conditional import by os)
WARNING: no module named ce (conditional import by os)
WARNING: no module named os2 (conditional import by os)
</pre>
<p>The analysis has detected that the import is within a conditional
block (an if statement).
You will know that in this system, <tt class="docutils literal">os</tt> will never need to import
the <tt class="docutils literal">os2</tt> module, for example, so that warning can be ignored.</p>
<p>Warnings may also be produced when a class or function is declared in
a package (an <tt class="docutils literal">__init__.py</tt> module), and the import specifies
<tt class="docutils literal">package.name</tt>. In this case, the analysis can't tell if name is supposed to
refer to a submodule or package.</p>
<p>Warnings are also produced when an <tt class="docutils literal">__import__</tt>, <tt class="docutils literal">exec</tt> or <tt class="docutils literal">eval</tt> statement is
encountered.
Either <tt class="docutils literal">exec</tt> and <tt class="docutils literal">eval</tt> could be used to implement a dynamic import,
but normally they are used for something else.
However, an <tt class="docutils literal">__import__</tt> warning should certainly be investigated.
It probably represents  a place where the script is importing code that <cite>PyInstaller</cite>
cannot see.</p>
<p>Problems detected through these messages can be corrected;
see <a class="reference internal" href="#listing-hidden-imports">Listing Hidden Imports</a> below for how to do it.</p>
</div>
<div class="section" id="build-time-python-errors">
<h3><a class="toc-backref" href="#id52">Build-Time Python Errors</a></h3>
<p><cite>PyInstaller</cite> sometimes terminates by raising a Python exception.
In most cases the reason is clear from the exception message,
for example &quot;Your system is not supported&quot;, or &quot;Pyinstaller
requires at least Python 2.4&quot;.
Others clearly indicate a bug that should be reported.</p>
<p>One of these errors can be puzzling, however:
<tt class="docutils literal"><span class="pre">IOError(&quot;Python</span> library not <span class="pre">found!&quot;)</span></tt>
<cite>PyInstaller</cite> needs to bundle the Python library, which is the
main part of the Python interpreter, linked as a dynamic load library.
The name and location of this file varies depending on the platform in use.
Some Python installations do not include a dynamic Python library
by default (a static-linked one may be present but cannot be used).
You may need to install a development package of some kind.
Or, the library may exist but is not in a folder where <cite>PyInstaller</cite>
is searching.</p>
<p>The places where <cite>PyInstaller</cite> looks for the python library are
different in different operating systems, but <tt class="docutils literal">/lib</tt> and <tt class="docutils literal">/usr/lib</tt>
are checked in most systems.
If you cannot put the python library there,
try setting the correct path in the environment variable
<tt class="docutils literal">LD_LIBRARY_PATH</tt> in Linux or
<tt class="docutils literal">DYLD_LIBRARY_PATH</tt> in OS X.</p>
</div>
<div class="section" id="getting-debug-messages">
<h3><a class="toc-backref" href="#id53">Getting Debug Messages</a></h3>
<p>Giving the <tt class="docutils literal"><span class="pre">--debug</span></tt> option causes the bundled executable itself to
write progress messages when it runs.
This can be useful during development of a complex package,
or when your app doesn't seem to be starting,
or just to learn how the runtime works.</p>
<p>Normally the debug progress messages go to standard output.
If the <tt class="docutils literal"><span class="pre">--windowed</span></tt> option is used when bundling a Windows app,
they are displayed as MessageBoxes.
For a <tt class="docutils literal"><span class="pre">--windowed</span></tt> Mac OS app they are not displayed.</p>
<p>Remember to bundle without <tt class="docutils literal"><span class="pre">--debug</span></tt> for your production version.
Users would find the messages annoying.</p>
</div>
<div class="section" id="getting-python-s-verbose-imports">
<h3><a class="toc-backref" href="#id54">Getting Python's Verbose Imports</a></h3>
<p>You can also pass a <tt class="docutils literal"><span class="pre">-v</span></tt> (verbose imports) flag to the embedded Python interpreter
(see <a class="reference internal" href="#giving-run-time-python-options">Giving Run-time Python Options</a> above).
This can be extremely useful.
It can be informative even with apps that are apparently working,
to make sure that they are getting all imports from the bundle,
and not leaking out to the local installed Python.</p>
<p>Python verbose and warning messages always go to standard output
and are not visible when the <tt class="docutils literal"><span class="pre">--windowed</span></tt> option is used.
Remember to not use this in the distributed program.</p>
</div>
</div>
<div class="section" id="helping-pyinstaller-find-modules">
<h2><a class="toc-backref" href="#id55">Helping PyInstaller Find Modules</a></h2>
<div class="section" id="extending-the-path">
<h3><a class="toc-backref" href="#id56">Extending the Path</a></h3>
<p>If Analysis recognizes that a module is needed, but cannot find that module,
it is often because the script is manipulating <tt class="docutils literal">sys.path</tt>.
The easiest thing to do in this case is to use the <tt class="docutils literal"><span class="pre">--paths=</span></tt> option
to list all the other places that the script might be searching for imports:</p>
<pre class="literal-block">
pyi-makespec --paths=/path/to/thisdir \
             --paths=/path/to/otherdir myscript.py
</pre>
<p>These paths will be added to the current <tt class="docutils literal">sys.path</tt> during analysis.</p>
</div>
<div class="section" id="listing-hidden-imports">
<h3><a class="toc-backref" href="#id57">Listing Hidden Imports</a></h3>
<p>If Analysis thinks it has found all the imports,
but the app fails with an import error,
the problem is a hidden import; that is, an import that is not
visible to the analysis phase.</p>
<p>Hidden imports can occur when the code is using <tt class="docutils literal">__import__</tt>
or perhaps <tt class="docutils literal">exec</tt> or <tt class="docutils literal">eval</tt>.
You get warnings of these (see <a class="reference internal" href="#build-time-messages">Build-time Messages</a>).</p>
<p>Hidden imports can also occur when an extension module uses the
Python/C API to do an import.
When this occurs, Analysis can detect nothing.
There will be no warnings, only a crash at run-time.</p>
<p>To find these hidden imports,
set the <tt class="docutils literal"><span class="pre">-v</span></tt> flag (<a class="reference internal" href="#getting-python-s-verbose-imports">Getting Python's Verbose Imports</a> above).</p>
<p>Once you know what they are, you add the needed modules
to the bundle using the <tt class="docutils literal"><span class="pre">--hidden-import=</span></tt> command option,
by editing the spec file, or
with a hook file (see <a class="reference internal" href="#using-hook-files">Using Hook Files</a> below).</p>
</div>
<div class="section" id="extending-a-package-s-path">
<h3><a class="toc-backref" href="#id58">Extending a Package's <tt class="docutils literal">__path__</tt></a></h3>
<p>Python allows a script to extend the search path used for imports
through the <tt class="docutils literal">__path__</tt> mechanism.
Normally, the <tt class="docutils literal">__path__</tt> of an imported module has only one entry,
the directory in which the <tt class="docutils literal">__init__.py</tt> was found.
But <tt class="docutils literal">__init__.py</tt> is free to extend its <tt class="docutils literal">__path__</tt> to include other directories.
For example, the <tt class="docutils literal">win32com.shell.shell</tt> module actually resolves to
<tt class="docutils literal">win32com/win32comext/shell/shell.pyd</tt>.
This is because <tt class="docutils literal">win32com/__init__.py</tt> appends <tt class="docutils literal"><span class="pre">../win32comext</span></tt> to its <tt class="docutils literal">__path__</tt>.</p>
<p>Because the <tt class="docutils literal">__init__.py</tt> of an imported module
is not actually executed during analysis,
changes it makes to <tt class="docutils literal">__path__</tt> are not seen by <cite>PyInstaller</cite>.
We fix the problem with the same hook mechanism we use for hidden imports,
with some additional logic; see <a class="reference internal" href="#using-hook-files">Using Hook Files</a> below.</p>
<p>Note that manipulations of <tt class="docutils literal">__path__</tt> hooked in this way apply only
to the analysis.
That is, at runtime <tt class="docutils literal">win32com.shell</tt> is resolved the same
way as <tt class="docutils literal">win32com.anythingelse</tt>, and <tt class="docutils literal">win32com.__path__</tt>
knows nothing of <tt class="docutils literal"><span class="pre">../win32comext</span></tt>.</p>
<p>Once in a while, that's not enough.</p>
</div>
<div class="section" id="changing-runtime-behavior">
<h3><a class="toc-backref" href="#id59">Changing Runtime Behavior</a></h3>
<p>More bizarre situations can be accomodated with runtime hooks.
These are small scripts that manipulate the environment before your main script runs,
effectively providing additional top-level code to your script.</p>
<p>There are two ways of providing runtime hooks.
You can name them with the option <tt class="docutils literal"><span class="pre">--runtime-hook=</span></tt><em>path-to-script</em>.</p>
<p>Second, some runtime hooks are provided.
At the end of an analysis,
the names in the module list produced by the Analysis phase are looked up in
<tt class="docutils literal">loader/rthooks.dat</tt> in the <cite>PyInstaller</cite> install folder.
This text file is the string representation of a
Python dictionary. The key is the module name, and the value is a list
of hook-script pathnames.
If there is a match, those scripts are included in the bundled app
and will be called before your main script starts.</p>
<p>Hooks you name with the option are executed
in the order given, and before any installed runtime hooks.
If you specify  <tt class="docutils literal"><span class="pre">--runtime-hook=file1.py</span> <span class="pre">--runtime-hook=file2.py</span></tt>
then the execution order at runtime will be:</p>
<ol class="arabic simple">
<li>Code of <tt class="docutils literal">file1.py</tt>.</li>
<li>Code of <tt class="docutils literal">file2.py</tt>.</li>
<li>Any hook specified for an included module that is found
in <tt class="docutils literal">rthooks/rthooks.dat</tt>.</li>
<li>Your main script.</li>
</ol>
<p>Hooks called in this way, while they need to be careful of what they import,
are free to do almost anything.
One reason to write a run-time hook is to
override some functions or variables from some modules.
A good example of this is the Django runtime
hook (see <tt class="docutils literal">loader/rthooks/pyi_rth_django.py</tt> in the
<cite>PyInstaller</cite> folder).
Django imports some modules dynamically and it is looking
for some <tt class="docutils literal">.py</tt> files.
However <tt class="docutils literal">.py</tt> files are not available in the one-file bundle.
We need to override the function
<tt class="docutils literal">django.core.management.find_commands</tt>
in a way that will just return a list of values.
The runtime hook does this as follows:</p>
<pre class="literal-block">
import django.core.management
def _find_commands(_):
    return &quot;&quot;&quot;cleanup shell runfcgi runserver&quot;&quot;&quot;.split()
django.core.management.find_commands = _find_commands
</pre>
</div>
</div>
</div>
<div class="section" id="advanced-topics">
<h1><a class="toc-backref" href="#id60">Advanced Topics</a></h1>
<div class="section" id="the-bootstrap-process-in-detail">
<h2><a class="toc-backref" href="#id61">The Bootstrap Process in Detail</a></h2>
<p>There are many steps that must take place before the bundled
script can begin execution.
A summary of these steps was given in the Overview
(<a class="reference internal" href="#how-the-one-folder-program-works">How the One-Folder Program Works</a> and
<a class="reference internal" href="#how-the-one-file-program-works">How the One-File Program Works</a>).
Here is more detail to help you understand what the bootloader
does and how to figure out problems.</p>
<div class="section" id="bootloader">
<h3><a class="toc-backref" href="#id62">Bootloader</a></h3>
<p>The bootloader prepares everything for running Python code.
It begins the setup and then returns itself in another process.
This approach of using two processes allows a lot of flexibility
and is used in all bundles except one-folder mode in Windows.
So do not be surprised if you will see your bundled app
as  two processes in your system task manager.</p>
<p>What happens during execution of bootloader:</p>
<ol class="upperalpha">
<li><p class="first">First process: bootloader starts.</p>
<blockquote>
<ol class="arabic simple">
<li>If one-file mode, extract bundled files to <em>temppath</em><tt class="docutils literal">_MEI</tt><em>xxxxxx</em></li>
<li>Set/unset various environment variables,
e.g. override LD_LIBRARY_PATH on Linux or LIBPATH on AIX;
unset DYLD_LIBRARY_PATH on OSX.</li>
<li>Set up to handle signals for both processes.</li>
<li>Run the child process.</li>
<li>Wait for the child process to finish.</li>
<li>If one-file mode, delete <em>temppath</em><tt class="docutils literal">_MEI</tt><em>xxxxxx</em>.</li>
</ol>
</blockquote>
</li>
<li><p class="first">Second process: bootloader itself started as a child process.</p>
<blockquote>
<ol class="arabic simple">
<li>On Windows set the <a class="reference external" href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa374153(v=vs.85).aspx">activation context</a>.</li>
<li>Load the Python dynamic library.
The name of the dynamic library is embedded in the
executable file.</li>
<li>Initialize Python interpreter: set PYTHONPATH, PYTHONHOME.</li>
<li>Run python code.</li>
</ol>
</blockquote>
</li>
</ol>
</div>
<div class="section" id="running-python-code">
<h3><a class="toc-backref" href="#id63">Running Python code</a></h3>
<p>Running Python code consists of several steps:</p>
<ol class="arabic simple">
<li>Run Python initialization code which
prepares everything for running the user's main script.
The initialization code can use only the Python built-in modules
because the general import mechanism is not yet available.
It sets up the python import mechanism to load modules
from archives embedded in the executable.
It also adds the attributes <tt class="docutils literal">frozen</tt>
and <tt class="docutils literal">_MEIPASS</tt> to the <tt class="docutils literal">sys</tt> built-in module.</li>
<li>Execute run run-time hooks: first those specified by the
user, then any standard ones.</li>
<li>Install python &quot;egg&quot; files.
When a module is part of a zip file (.egg),
it has been bundled into the <tt class="docutils literal">./eggs</tt> directory.
Installing means appending .egg file names to <tt class="docutils literal">sys.path</tt>.
Python automatically detects whether an
item in <tt class="docutils literal">sys.path</tt> is a zip file or a directory.</li>
<li>Run the main script.</li>
</ol>
</div>
<div class="section" id="python-imports-in-a-bundled-app">
<h3><a class="toc-backref" href="#id64">Python imports in a bundled app</a></h3>
<p><cite>PyInstaller</cite> embeds compiled python code
(<tt class="docutils literal">.pyc</tt> files) within the executable.
<cite>PyInstaller</cite> injects its code into the
normal Python import mechanism.
Python allows this;
the support is described in <a class="reference external" href="http://www.python.org/dev/peps/pep-0302/">PEP 302</a>  &quot;New Import Hooks&quot;.</p>
<p>PyInstaller implements the PEP 302 specification for
importing built-in modules,
importing &quot;frozen&quot; modules (compiled python code
bundled with the app) and for C-extensions.
The code can be read in <tt class="docutils literal">./PyInstaller/loader/pyi_importers.py</tt>.</p>
<p>At runtime the PyInstaller PEP 302 hooks are appended
to the variable <tt class="docutils literal">sys.meta_path</tt>.
When trying to import modules the interpreter will
first try PEP 302 hooks in <tt class="docutils literal">sys.meta_path</tt>
before searching in <tt class="docutils literal">sys.path</tt>.
As a result, the Python interpreter
loads imported python modules from the archive embedded
in the bundled executable.</p>
<p>This is the resolution order of import statements
in a bundled app:</p>
<ol class="arabic simple">
<li>Is it a built-in module?
A list of built-in modules is in variable
<tt class="docutils literal">sys.builtin_module_names</tt>.</li>
<li>Is it a module embedded in the executable?
Then load it from embedded archive.</li>
<li>Is it a C-extension?
The app will try to find a file with name
<em>package.subpackage.module</em><tt class="docutils literal">.pyd</tt> or
<em>package.subpackage.module</em><tt class="docutils literal">.so</tt></li>
<li>Next examine paths in the <tt class="docutils literal">sys.path</tt> (PYTHONPATH).
There could be any additional location with python modules
or <tt class="docutils literal">.egg</tt> filenames.</li>
<li>If the module was not found then
raise <tt class="docutils literal">ImportError</tt>.</li>
</ol>
</div>
</div>
<div class="section" id="adapting-to-being-frozen">
<h2><a class="toc-backref" href="#id65">Adapting to being &quot;frozen&quot;</a></h2>
<p>You might want to learn at run-time
whether the app is running &quot;live&quot; (from source) or &quot;frozen&quot; (bundled).
For example, you might have
data files that, when running live, are found based on a module's
<tt class="docutils literal">__file__</tt> attribute.
That won't work when the code is bundled.</p>
<p>The <cite>PyInstaller</cite> bootloader adds the name <tt class="docutils literal">frozen</tt> to the <tt class="docutils literal">sys</tt> module.
So the test for &quot;are we bundled?&quot; is:</p>
<pre class="literal-block">
if getattr(sys, 'frozen', False):
        # running in a bundle
</pre>
</div>
<div class="section" id="accessing-data-files">
<h2><a class="toc-backref" href="#id66">Accessing Data Files</a></h2>
<p>You can include related files in either type of distribution.
Data files and folders of files can be included
by editing the spec file; see <a class="reference internal" href="#adding-files-to-the-bundle">Adding Files to the Bundle</a>.</p>
<p>The bootloader stores the absolute path to the bundle folder in <tt class="docutils literal">sys._MEIPASS</tt>.
For a one-folder bundle, this is the path to that folder.
For a one-file bundle, this is the path to the <tt class="docutils literal">_MEIxxxxxx</tt> temporary folder
created by the bootloader (see <a class="reference internal" href="#how-the-one-file-program-works">How the One-File Program Works</a>).</p>
<p>When your application needs access to a data file that is bundled with it,
for example a configuration file or an icon image file,
you get the path to the file with the following code:</p>
<pre class="literal-block">
import sys
import os
...
if getattr(sys, 'frozen', False):
    # we are running in a |PyInstaller| bundle
    basedir = sys._MEIPASS
else:
    # we are running in a normal Python environment
    basedir = os.path.dirname(os.path.abspath(__file__))
</pre>
<p>This code sets <tt class="docutils literal">basedir</tt> to the path to the folder containing
your script and any other files or folders bundled with it.
When your program was not started by the bootloader, the standard Python
variable <tt class="docutils literal">__file__</tt> is the full path to the script now executing,
and <tt class="docutils literal">os.path.dirname()</tt> extracts the path to the folder that contains it.
When bundled, <tt class="docutils literal">sys._MEIPASS</tt> provides the path to bundle folder.</p>
<p>In the one-folder distribution,
bundled data files are in the distribution folder.
Your code can make useful changes to files in the folder.</p>
<p>In the one-file mode, bundled data files are packaged into the executable.
The bootloader unpacks them into a temporary folder.
The <tt class="docutils literal">basedir</tt> path discovered by the code above
is the path to this temporary folder.
Any files your code creates or modifies in that folder
are available only while the app is running.
When it ends they will be deleted.</p>
</div>
<div class="section" id="capturing-version-data">
<h2><a class="toc-backref" href="#id67">Capturing Version Data</a></h2>
<blockquote>
<tt class="docutils literal"><span class="pre">pyi-grab_version</span></tt> <em>executable_with_version_resource</em></blockquote>
<p>The <tt class="docutils literal"><span class="pre">pyi-grab_version</span></tt> command is invoked
with the full path name of a Windows executable
that has a Version resource.
(A Version resource contains a group of data structures,
some containing binary integers and some containing strings,
that describe the properties of the executable.
For details see the <a class="reference external" href="http://msdn.microsoft.com/en-us/library/ff468916(v=vs.85).aspx">Version Information Structures</a> page.)</p>
<p>The command writes text that represents
a Version resource in readable form.
The version text is written to standard output.
You can copy it from the console window or redirect it to a file.
Then you can edit the version information to adapt it to your program.
This approach is used because version resources are complex.
Some elements are optional, others required.
When you view the version tab of a Properties dialog,
there's no simple relationship between
the data displayed and the structure of the resource.
Using <tt class="docutils literal"><span class="pre">pyi-grab_version</span></tt> you can find an executable that displays the kind of
information you want, copy its resource data, and modify it to suit your package.</p>
<p>The version text file is encoded UTF-8 and may contain non-ASCII characters.
(Unicode characters are allowed in Version resource string fields.)
Be sure to edit and save the text file in UTF-8 unless you are
certain it contains only ASCII string values.</p>
<p>The edited version text file can be given with a <tt class="docutils literal"><span class="pre">--version-file=</span></tt>
option to <tt class="docutils literal">pyinstaller</tt> or <tt class="docutils literal"><span class="pre">pyi-makespec</span></tt>.
The text data is converted to a Version resource and
installed in the executable output.</p>
<p>In a Version resource there are two 64-bit binary values,
<tt class="docutils literal">FileVersion</tt> and <tt class="docutils literal">ProductVersion</tt>.
In the version text file these are given as four-element tuples,
for example:</p>
<pre class="literal-block">
filevers=(2, 0, 4, 0),
prodvers=(2, 0, 4, 0),
</pre>
<p>The elements of each tuple represent 16-bit values
from most-significant to least-significant.
For example the <tt class="docutils literal">FileVersion</tt> value given resolves to
<tt class="docutils literal">0002000000040000</tt> in hex.</p>
<blockquote>
<tt class="docutils literal">set_version</tt> <em>version_text_file</em> <em>executable_file</em></blockquote>
<p>The <tt class="docutils literal">set_version</tt> utility reads a version text file as written
by <tt class="docutils literal"><span class="pre">pyi-grab_version</span></tt>, converts it to a Version resource,
and installs that resource in the <em>executable_file</em> specified.</p>
<p>For advanced uses, examine a version text file.
You find it is Python code that creates a <tt class="docutils literal">VSVersionInfo</tt> object.
The class definition for <tt class="docutils literal">VSVersionInfo</tt> is found in
<tt class="docutils literal">utils/versioninfo.py</tt> in the <cite>PyInstaller</cite> distribution folder.
You can write a program that imports that module.
In that program you can <tt class="docutils literal">eval</tt>
the contents of a version info text file to produce a
<tt class="docutils literal">VSVersionInfo</tt> object.
You can use the <tt class="docutils literal">.toRaw()</tt> method of that object to
produce a Version resource in binary form.
Or you can apply the <tt class="docutils literal">unicode()</tt> function to the object
to reproduce the version text file.</p>
</div>
<div class="section" id="inspecting-archives">
<h2><a class="toc-backref" href="#id68">Inspecting Archives</a></h2>
<p>An archive is a file that contains other files,
for example a <tt class="docutils literal">.tar</tt> file, a <tt class="docutils literal">.jar</tt> file, or a <tt class="docutils literal">.zip</tt> file.
Two kinds of archives are used in <cite>PyInstaller</cite>.
One is a ZlibArchive, which
allows Python modules to be stored efficiently and,
with some import hooks, imported directly.
The other, a CArchive, is similar to a <tt class="docutils literal">.zip</tt> file,
a general way of packing up (and optionally compressing) arbitrary blobs of data.
It gets its name from the fact that it can be manipulated easily from C
as well as from Python.
Both of these derive from a common base class, making it fairly easy to
create new kinds of archives.</p>
<div class="section" id="zlibarchive">
<h3><a class="toc-backref" href="#id69">ZlibArchive</a></h3>
<p>A ZlibArchive contains compressed <tt class="docutils literal">.pyc</tt> or <tt class="docutils literal">.pyo</tt> files.
The <tt class="docutils literal">PYZ</tt> class invocation in a spec file creates a ZlibArchive.</p>
<p>The table of contents in a ZlibArchive
is a Python dictionary that associates a key,
which is a member's name as given in an <tt class="docutils literal">import</tt> statement,
with a seek position and a length in the ZlibArchive.
All parts of a ZlibArchive are stored in the
<a class="reference external" href="http://docs.python.org/library/marshal">marshalled</a> format and so are platform-independent.</p>
<p>A ZlibArchive is used at run-time to import bundled python modules.
Even with maximum compression this works  faster than the normal import.
Instead of searching <tt class="docutils literal">sys.path</tt>, there's a lookup in the dictionary.
There are no directory operations and no
file to open (the file is already open).
There's just a seek, a read and a decompress.</p>
<p>A Python error trace will point to the source file from which the archive
entry was created (the <tt class="docutils literal">__file__</tt> attribute from the time the
<tt class="docutils literal">.pyc</tt> was compiled, captured and saved in the archive).
This will not tell your user anything useful,
but if they send you a Python error trace,
you can make sense of it.</p>
<p><img alt="ZlibArchiveImage" src="images/ZlibArchive.png" /></p>
</div>
<div class="section" id="carchive">
<h3><a class="toc-backref" href="#id70">CArchive</a></h3>
<p>A CArchive can contain any kind of file.
It's very much like a <tt class="docutils literal">.zip</tt> file.
They are easy to create in Python and easy to unpack from C code.
A CArchive can be appended to another file, such as
an ELF and COFF executable.
To allow this, the archive is made with its table of contents at the
end of the file, followed only by a cookie that tells where the
table of contents starts and
where the archive itself starts.</p>
<p>A CArchive can be embedded within another CArchive.
An inner archive can be opened and used in place,
without having to extract it.</p>
<p>Each table of contents entry has variable length.
The first field in the entry gives the length of the entry.
The last field is the name of the corresponding packed file.
The name is null terminated.
Compression is optional for each member.</p>
<p>There is also a type code associated with each member.
The type codes are used by the self-extracting executables.
If you're using a <tt class="docutils literal">CArchive</tt> as a <tt class="docutils literal">.zip</tt> file, you don't need to worry about the code.</p>
<p>The ELF executable format (Windows, Linux and some others) allows arbitrary
data to be concatenated to the end of the executable without disturbing its
functionality. For this reason, a CArchive's Table of Contents is
at the end of the archive. The executable can open itself as a binary
file, seek to the end and 'open' the CArchive.</p>
<p><img alt="CArchiveImage" src="images/CArchive.png" /></p>
</div>
<div class="section" id="using-pyi-archive-viewer">
<h3><a class="toc-backref" href="#id71">Using pyi-archive_viewer</a></h3>
<p>Use the <tt class="docutils literal"><span class="pre">pyi-archive_viewer</span></tt> command to inspect any type of archive:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">pyi-archive_viewer</span></tt> <em>archivefile</em></blockquote>
<p>With this command you can examine the contents of any archive built with
<cite>PyInstaller</cite> (a <tt class="docutils literal">PYZ</tt> or <tt class="docutils literal">PKG</tt>), or any executable (<tt class="docutils literal">.exe</tt> file
or an ELF or COFF binary).
The archive can be navigated using these commands:</p>
<dl class="docutils">
<dt>O <em>name</em></dt>
<dd>Open the embedded archive <em>name</em> (will prompt if omitted).
For example when looking in a one-file executable, you
can open the <tt class="docutils literal">outPYZ.pyz</tt> archive inside it.</dd>
<dt>U</dt>
<dd>Go up one level (back to viewing the containing archive).</dd>
<dt>X <em>name</em></dt>
<dd>Extract <em>name</em> (will prompt if omitted).
Prompts for an output filename.
If none given, the member is extracted to stdout.</dd>
<dt>Q</dt>
<dd>Quit.</dd>
</dl>
<p>The <tt class="docutils literal"><span class="pre">pyi-archive_viewer</span></tt> command has these options:</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-h</span>, <span class="option">--help</span></kbd></td>
<td>Show help.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-l</span>, <span class="option">--log</span></kbd></td>
<td>Quick contents log.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-b</span>, <span class="option">--brief</span></kbd></td>
<td>Print a python evaluable list of contents filenames.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">-r</span>, <span class="option">--recursive</span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Used with -l or -b, applies recursive behaviour.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="inspecting-executables">
<h2><a class="toc-backref" href="#id72">Inspecting Executables</a></h2>
<p>You can inspect any executable file with <tt class="docutils literal"><span class="pre">pyi-bindepend</span></tt>:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">pyi-bindepend</span></tt> <em>executable_or_dynamic_library</em></blockquote>
<p>The <tt class="docutils literal"><span class="pre">pyi-bindepend</span></tt> command analyzes the executable or DLL you name
and writes to stdout all its binary dependencies.
This is handy to find out which DLLs are required by
an executable or by another DLL.</p>
<p><tt class="docutils literal"><span class="pre">pyi-bindepend</span></tt> is used by <cite>PyInstaller</cite> to
follow the chain of dependencies of binary extensions
during Analysis.</p>
</div>
<div class="section" id="multipackage-bundles">
<h2><a class="toc-backref" href="#id73">Multipackage Bundles</a></h2>
<p>Some products are made of several different apps,
each of which might
depend on a common set of third-party libraries, or share code in other ways.
When packaging such an product it
would be a pity to treat each app in isolation, bundling it with
all its dependencies, because that means storing duplicate copies
of code and libraries.</p>
<p>You can use the multipackage feature to bundle a set of executable apps
so that they share single copies of libraries.
Each dependency (a DLL, for example) is packaged only once, in one of the apps.
Any other apps in the set that depend on that DLL
have an &quot;external reference&quot; to it, telling them
to go find that dependency in the executable file of the app that contains it.</p>
<p>This saves disk space because each dependency is stored only once.
However, to follow an external reference takes extra time when an app is starting up.
Some of the apps in the set will have slightly slower launch times.</p>
<p>The external references between binaries include hard-coded
paths to the output directory, and cannot be rearranged.
If you use one-folder mode, you must
install all the application folders within a single parent directory.
If you use one-file mode, you must place all
the related applications in the same directory
when you install the application.</p>
<p>To build such a set of apps you must code a custom
spec file that contains  a call to the <a class="reference internal" href="#merge-function">MERGE Function</a>.
This function takes a list of analyzed scripts,
finds their common dependencies, and modifies the analyses
to minimize the storage cost.</p>
<p>The order of the analysis objects in the argument list matters.
The MERGE function packages each dependency into the
first script from left to right that needs that dependency.
A script that comes later in the list and needs the same file
will have an external reference.
You might sequence the scripts to place the most-used scripts first in the list.</p>
<div class="section" id="merge-function">
<h3><a class="toc-backref" href="#id74">MERGE Function</a></h3>
<p>A custom spec file for a multipackage bundle contains one call to the MERGE function:</p>
<pre class="literal-block">
MERGE(*args)
</pre>
<p>MERGE is used after the analysis phase and before <tt class="docutils literal">EXE</tt> and <tt class="docutils literal">COLLECT</tt>.
Its variable-length list of arguments consists of
a list of tuples, each tuple having three elements:</p>
<ul class="simple">
<li>The first element is an Analysis object, an instance of class Analysis.</li>
<li>The second element is the script name (without the <tt class="docutils literal">.py</tt> extension).</li>
<li>The third element is the name for the executable (usually the same as the script).</li>
</ul>
<p>MERGE examines the Analysis objects to learn the dependencies of each script.
It modifies the total list to avoid duplication of libraries and modules.
As a result the packages generated will be connected.</p>
</div>
<div class="section" id="example-merge-spec-file">
<h3><a class="toc-backref" href="#id75">Example MERGE spec file</a></h3>
<p>One way to construct a spec file for a multipackage bundle is to
first build a spec file for each app in the package.
Suppose you have a product that comprises three apps named
(because we have no imagination) <tt class="docutils literal">foo</tt>, <tt class="docutils literal">bar</tt> and <tt class="docutils literal">zap</tt>:</p>
<pre class="literal-block">
pyi-makespec options as appropriate... foo.py
pyi-makespec options as appropriate... bar.py
pyi-makespec options as appropriate... zap.py
</pre>
<p>Check for warnings and test the apps individually.
Deal with any hidden imports and other problems.
When all three work correctly,
edit the three files <tt class="docutils literal">foo.spec</tt>, <tt class="docutils literal">bar.spec</tt> and <tt class="docutils literal">zap.spec</tt>
and combine them as follows.
First copy the Analysis statements from each,
changing them to give each Analysis object a unique name:</p>
<pre class="literal-block">
foo_a = Analysis(['foo.py'],
        pathex=['/the/path/to/foo'],
        hiddenimports=[],
        hookspath=None)

bar_a = Analysis(['bar.py'], etc., etc...

zap_a = Analysis(['zap.py'], etc., etc...
</pre>
<p>Now code the call to MERGE to process the three Analysis objects:</p>
<pre class="literal-block">
MERGE( (foo_a, 'foo', 'foo'), (bar_a, 'bar', 'bar'), (zap_a, 'zap', 'zap') )
</pre>
<p>Following this you can copy the <tt class="docutils literal">PYZ</tt>, <tt class="docutils literal">EXE</tt> and <tt class="docutils literal">COLLECT</tt> statements from
the original three spec files,
substituting the unique names of the Analysis objects
where the original spec files have <tt class="docutils literal">a.</tt>, for example:</p>
<pre class="literal-block">
foo_pyz = PYZ(foo_a.pure)
foo_exe = EXE(foo_pyz, foo_a.scripts, ... etc.
</pre>
<p>Save the merged spec file as <tt class="docutils literal">foobarzap.spec</tt> and then build it:</p>
<pre class="literal-block">
pyi-build foobarzap.spec
</pre>
<p>There are several multipackage examples in the <tt class="docutils literal">tests/multipackage</tt> folder
of the <cite>PyInstaller</cite> distribution folder.</p>
<p>Remember that a spec file is executable Python.
You can use all the Python facilities (<tt class="docutils literal">for</tt> and <tt class="docutils literal">with</tt>
and the members of <tt class="docutils literal">sys</tt> and <tt class="docutils literal">io</tt>)
in creating the Analysis
objects and performing the <tt class="docutils literal">PYZ</tt>, <tt class="docutils literal">EXE</tt> and <tt class="docutils literal">COLLECT</tt> statements.</p>
</div>
</div>
<div class="section" id="using-hook-files">
<h2><a class="toc-backref" href="#id76">Using Hook Files</a></h2>
<p>In summary, a &quot;hook&quot; file tells <cite>PyInstaller</cite> about hidden imports
called by a particular module.
The name of the hook file is <tt class="docutils literal"><span class="pre">hook-&lt;module&gt;.py</span></tt> where &quot;&lt;module&gt;&quot; is
the name of a script or imported module that will be found by Analysis.
You should browse through the existing hooks in the
<tt class="docutils literal">hooks</tt> folder of the <cite>PyInstaller</cite> distribution folder,
if only to see the names of the many supported imports.</p>
<p>For example <tt class="docutils literal"><span class="pre">hook-cPickle.py</span></tt> is a hook file telling
about hidden imports used by the module <tt class="docutils literal">cPickle</tt>.
When your script has <tt class="docutils literal">import cPickle</tt>
the Analysis will note it and check for a hook file <tt class="docutils literal"><span class="pre">hook-cPickle.py</span></tt>.</p>
<p>Typically a hook module has only one line; in <tt class="docutils literal"><span class="pre">hook-cPickle.py</span></tt> it is</p>
<blockquote>
<tt class="docutils literal">hiddenimports = ['copy_reg', 'types', 'string']</tt></blockquote>
<p>assigning a list of one or more module names to <tt class="docutils literal">hiddenimports</tt>.
These module names are added to the Analysis list exactly as if the
script being analyzed had imported them by name.</p>
<p>When the module that needs these hidden imports is local to your project,
store the hook file(s) somewhere near your source file.
Then specify their location to the <tt class="docutils literal">pyinstaller</tt> or <tt class="docutils literal"><span class="pre">pyi-makespec</span></tt>
command with the <tt class="docutils literal"><span class="pre">--additional-hooks-dir=</span></tt> option.
If the hook file(s) are at the same level as the script,
the command could be simply</p>
<blockquote>
<tt class="docutils literal">pyinstaller <span class="pre">--additional-hooks-dir=.</span> myscript.py</tt></blockquote>
<p>If you successfully hook a publicly distributed module in this way,
please send us the hook file so we can make it available to others.</p>
</div>
<div class="section" id="hooks-in-detail">
<h2><a class="toc-backref" href="#id77">Hooks in Detail</a></h2>
<p>A hook is a module named
<tt class="docutils literal">hook-</tt> <em>fully.qualified.import.name</em> <tt class="docutils literal">.py</tt> in the
<tt class="docutils literal">hooks</tt> folder of the <cite>PyInstaller</cite> folder
(or in a folder specified with <tt class="docutils literal"><span class="pre">--additional-hooks-dir</span></tt>).</p>
<p>A hook is executable Python code that should
define one or more of the following three global names:</p>
<dl class="docutils">
<dt><tt class="docutils literal">hiddenimports</tt></dt>
<dd><p class="first">A list of module names (relative or absolute) that the
hooked module imports in some opaque way.
These names extend the list of imported modules created
by scanning the code. Example:</p>
<pre class="literal-block">
hiddenimports = ['_proxy', 'utils', 'defs']
</pre>
<p>A way to simplify adding all submodules of a package is to use:</p>
<pre class="literal-block">
from PyInstaller.hooks.hookutils import collect_submodules
hiddenimports = collect_submodules('package')
</pre>
<p>For an example see <tt class="docutils literal"><span class="pre">hook-docutils.py</span></tt> in the hooks folder.</p>
<p class="last">Note: We suggest always using the fully qualified name
<tt class="docutils literal">PyInstaller.hooks.hookutils</tt> for importing hookutils. This
avoids some pitfalls when implementing hooks for sub-modules.</p>
</dd>
<dt><tt class="docutils literal">datas</tt></dt>
<dd><p class="first">A list of globs of files or directories to bundle as datafiles. For
each glob, a destination directory is specified.</p>
<p>Example:</p>
<pre class="literal-block">
datas = [
     ('/usr/share/icons/education_*.png', 'icons'),
     ('/usr/share/libsmi/mibs/*', 'mibs'),
     ]
</pre>
<p>This will copy all files matching <cite>education_*.png</cite> into the
subdirectory <cite>icons</cite>,
and recursively (because of the <tt class="docutils literal">*</tt> wildcard)
copy the content of <cite>/usr/share/libsmi/mibs</cite> into <cite>mibs</cite>.</p>
<p>A way to simplify collecting a folder of files is to use:</p>
<pre class="literal-block">
from hookutils import collect_data_files
datas = collect_data_files('package_name')
</pre>
<p class="last">to collect all package-related data files into a folder
<em>package_name</em> in the app bundle.
For an example see hook-pytz.py in the hooks folder.</p>
</dd>
<dt><tt class="docutils literal">attrs</tt></dt>
<dd><p class="first">A list of <tt class="docutils literal">(</tt> <em>name</em> <tt class="docutils literal">,</tt> <em>value</em> <tt class="docutils literal">)</tt> pairs
(where value is normally meaningless).</p>
<p>This will set the module-attribute <em>name</em> to <em>value</em> for each
pair in the list. The value is usually unimportant because the
modules are not executed.</p>
<p class="last">The main purpose is so that ImportTracker will not issue spurious
warnings when the rightmost node in a dotted name turns out to be
an attribute in a package, instead of a missing submodule.
For an example see the hook file <tt class="docutils literal"><span class="pre">hook-xml.sax.py</span></tt>.</p>
</dd>
<dt><tt class="docutils literal">def hook(mod):</tt></dt>
<dd>Defines a function that takes a <tt class="docutils literal">Module</tt> object.
It must return a <tt class="docutils literal">Module</tt> object, possibly the same one
unchanged, or a modified one.
A <tt class="docutils literal">Module</tt> object is an instance of the class
<tt class="docutils literal">PyInstaller.depend.modules.Module()</tt> which you can read.
If defined, <tt class="docutils literal">hook(mod)</tt> is called before <cite>PyInstaller</cite> tests
<tt class="docutils literal">hiddenimports</tt>,  <tt class="docutils literal">datas</tt>, or <tt class="docutils literal">attrs</tt>.
So one use of a <tt class="docutils literal">hook(mod)</tt>
function would be to test <tt class="docutils literal">sys.version</tt> and adjust
<tt class="docutils literal">hiddenimports</tt> based on that.</dd>
</dl>
<p>This function is supported to handle cases like dynamic modification of a
package's <tt class="docutils literal">__path__</tt> variable.
A static list of names won't suffice
because the new entry on <tt class="docutils literal">__path__</tt> may well require computation.
See <tt class="docutils literal"><span class="pre">hook-win32com.py</span></tt> in the hooks folder for an example.</p>
</div>
<div class="section" id="building-the-bootloader">
<h2><a class="toc-backref" href="#id78">Building the Bootloader</a></h2>
<p>PyInstaller comes with binary bootloaders for most platforms in
the <tt class="docutils literal">bootloader</tt> folder of the distribution folder.
For most cases, these precompiled bootloaders are all you need.</p>
<p>If there is no precompiled bootloader for your platform,
or if you want to modify the bootloader source,
you need to build the bootloader.</p>
<div class="section" id="development-tools">
<h3><a class="toc-backref" href="#id79">Development tools</a></h3>
<p>On Debian/Ubuntu systems, you can run the following to
install everything required:</p>
<pre class="literal-block">
sudo apt-get install build-essential
</pre>
<p>On Fedora/RHEL and derivates, you can run the following:</p>
<pre class="literal-block">
su
yum groupinstall &quot;Development Tools&quot;
</pre>
<p>On Mac OS X you can get gcc by installing <a class="reference external" href="http://developer.apple.com/xcode">Xcode</a>. It is a suite of tools
for developing software for Mac OS X. It can be also installed from your
Mac OS X Install DVD. It is not necessary to install the version 4 of Xcode.</p>
<p>On Solaris and AIX the bootloader is tested with gcc.</p>
<p>On Windows you can use the Visual Studio C++ compiler
(Visual Studio 2008 is recommended).
A free version you can download is <a class="reference external" href="http://www.microsoft.com/express/">Visual Studio Express</a>.</p>
<p><em>Note:</em> There is no connection between the Visual Studio
version used to compile the bootloader and the Visual Studio version used to
compile Python. The bootloader is a self-contained static executable
that imposes no restrictions on the version of Python being used. So
you can use any Visual Studio version you have around.</p>
<p>You can download and install or unpack MinGW distribution from one of the
following locations:</p>
<ul class="simple">
<li><a class="reference external" href="http://sourceforge.net/downloads/mingw/">MinGW</a> - stable and mature, uses gcc 3.4 as its base</li>
<li><a class="reference external" href="http://mingw-w64.sourceforge.net/">MinGW-w64</a> - more recent, uses gcc 4.4 and up.</li>
<li><a class="reference external" href="http://tdm-gcc.tdragon.net/">TDM-GCC</a> - MinGW and MinGW-w64 installers</li>
</ul>
</div>
<div class="section" id="building">
<h3><a class="toc-backref" href="#id80">Building</a></h3>
<p>On Windows, when using MinGW, it is needed to add <tt class="docutils literal">PATH_TO_MINGW\bin</tt>
to your system <tt class="docutils literal">PATH</tt>. variable. In command prompt before building
bootloader run for example:</p>
<pre class="literal-block">
set PATH=C:\MinGW\bin;%PATH%
</pre>
<p>Change to the <tt class="docutils literal">bootloader</tt> subdirectory. Run:</p>
<pre class="literal-block">
python ./waf configure build install
</pre>
<p>This will produce</p>
<ul class="simple">
<li><tt class="docutils literal">./PyInstaller/bootloader/YOUR_OS/run</tt>,</li>
<li><tt class="docutils literal">./PyInstaller/bootloader/YOUR_OS/run_d</tt></li>
<li><tt class="docutils literal">./PyInstaller/bootloader/YOUR_OS/runw</tt> and</li>
<li><tt class="docutils literal">./PyInstaller/bootloader/YOUR_OS/runw_d</tt></li>
</ul>
<p>which are the bootloaders.</p>
<p>On Windows this will produce in the <tt class="docutils literal">./PyInstaller/bootloader/YOUR_OS</tt> directory:
<tt class="docutils literal"><span class="pre">run*.exe</span></tt> (bootloader for regular programs), and
<tt class="docutils literal"><span class="pre">inprocsrvr*.dll</span></tt> (bootloader for in-process COM servers).</p>
<p><em>Note:</em> If you have multiple versions of Python, the Python you use to run
<tt class="docutils literal">waf</tt> is the one whose configuration is used.</p>
<p><em>Note:</em> On AIX the bootloader builds with gcc and is tested with gcc 4.2.0 on AIX 6.1.</p>
</div>
<div class="section" id="linux-standard-base-lsb-binary">
<h3><a class="toc-backref" href="#id81">Linux Standard Base (LSB) binary</a></h3>
<p>By default, the bootloaders on Linux are LSB binaries.</p>
<p>LSB is a set of open standards that should increase compatibility among Linux
distributions.
<cite>PyInstaller</cite> produces a bootloader as an LSB binary in order
to increase compatibility for packaged applications among distributions.</p>
<p><em>Note:</em> LSB version 4.0 is required for successfull building of bootloader.</p>
<p>On Debian- and Ubuntu-based distros, you can install LSB 4.0 tools by adding
the following repository to the sources.list file:</p>
<pre class="literal-block">
deb http://ftp.linux-foundation.org/pub/lsb/repositories/debian lsb-4.0 main
</pre>
<p>then after having update the apt repository:</p>
<pre class="literal-block">
sudo apt-get update
</pre>
<p>you can install LSB 4.0:</p>
<pre class="literal-block">
sudo apt-get install lsb lsb-build-cc
</pre>
<p>Most other distributions contain only LSB 3.0 in their software
repositories and thus LSB build tools 4.0 must be downloaded by hand.
From Linux Foundation download <a class="reference external" href="http://ftp.linuxfoundation.org/pub/lsb/bundles/released-4.0.0/sdk/">LSB sdk 4.0</a> for your architecture.</p>
<p>Unpack it by:</p>
<pre class="literal-block">
tar -xvzf lsb-sdk-4.0.3-1.ia32.tar.gz
</pre>
<p>To install it run:</p>
<pre class="literal-block">
cd lsb-sdk
./install.sh
</pre>
<p>After having installed the LSB tools, you can follow the standard building
instructions.</p>
<p><em>NOTE:</em> if for some reason you want to avoid LSB compilation, you can
do so by specifying --no-lsb on the waf command line, as follows:</p>
<pre class="literal-block">
python waf configure --no-lsb build install
</pre>
<p>This will also produce <tt class="docutils literal">support/loader/YOUR_OS/run</tt>,
<tt class="docutils literal">support/loader/YOUR_OS/run_d</tt>, <tt class="docutils literal">support/loader/YOUR_OS/runw</tt> and
<tt class="docutils literal">support/loader/YOUR_OS/runw_d</tt>, but they will not be LSB binaries.</p>
</div>
</div>
<div class="section" id="modulefinder-replacement-importtracker">
<h2><a class="toc-backref" href="#id82">Modulefinder Replacement - ImportTracker</a></h2>
<p>The Imptracker package
(defined in <tt class="docutils literal">depend/imptracker.py</tt> in the <cite>PyInstaller</cite> folder)
replaces <a class="reference external" href="http://docs.python.org/2.7/library/modulefinder.html">Modulefinder</a> but is modelled after <a class="reference internal" href="#iu-py">iu.py</a>.
The <tt class="docutils literal">modulegraph</tt> package, which is similar,
will be supported in a future release.</p>
<p>Imptracker, like Modulefinder,
uses <tt class="docutils literal">ImportDirectors</tt> and <tt class="docutils literal">Owners</tt> to partition the
import name space. Except for the fact that these return <tt class="docutils literal">Module</tt>
instances instead of real module objects, they are identical.</p>
<p>Instead of an <tt class="docutils literal">ImportManager</tt>, it has an <tt class="docutils literal">ImportTracker</tt> managing things.</p>
<div class="section" id="importtracker">
<h3><a class="toc-backref" href="#id83">ImportTracker</a></h3>
<p><tt class="docutils literal">ImportTracker</tt> can be called in two ways: <tt class="docutils literal">analyze_one(name,
importername=None)</tt> or <tt class="docutils literal">analyze_r(name, importername=None)</tt>. The
second method does what modulefinder does - it recursively finds all
the module names that importing name would cause to appear in
<tt class="docutils literal">sys.modules</tt>. The first method is non-recursive. This is useful,
because it is the only way of answering the question &quot;Who imports
name?&quot; But since it is somewhat unrealistic (very few real imports do
not involve recursion), it deserves some explanation.</p>
</div>
<div class="section" id="analyze-one">
<h3><a class="toc-backref" href="#id84"><tt class="docutils literal">analyze_one()</tt></a></h3>
<p>When a name is imported, there are structural and dynamic effects.
The dynamic
effects are due to the execution of the top-level code in the module (or
modules) that get imported. The structural effects have to do with whether the
import is relative or absolute, and whether the name is a dotted name (if there
are N dots in the name, then N+1 modules will be imported even without any code
running).</p>
<p>The analyze_one method determines the structural effects, and defers
the dynamic effects. For example, <tt class="docutils literal"><span class="pre">analyze_one(&quot;B.C&quot;,</span> &quot;A&quot;)</tt> could
return <tt class="docutils literal">[&quot;B&quot;, &quot;B.C&quot;]</tt> or <tt class="docutils literal">[&quot;A.B&quot;, &quot;A.B.C&quot;]</tt> depending on whether
the import turns out to be relative or absolute. In addition,
ImportTracker's modules dict will have Module instances for them.</p>
</div>
<div class="section" id="module-classes">
<h3><a class="toc-backref" href="#id85">Module Classes</a></h3>
<p>There are Module subclasses for builtins, extensions, packages and (normal)
modules. Besides the normal module object attributes, they have an attribute
imports. For packages and normal modules, imports is a list populated by
scanning the code object (and therefor, the names in this list may be relative
or absolute names - we don't know until they have been analyzed).</p>
<p>The highly astute will notice that there is a hole in
<tt class="docutils literal">analyze_one()</tt> here. The first thing that happens when <tt class="docutils literal">B.C</tt> is
being imported is that <tt class="docutils literal">B</tt> is imported and its top-level code
executed. That top-level code can do various things so that when the
import of <tt class="docutils literal">B.C</tt> finally occurs, something completely different
happens (from what a structural analysis would predict). But mf can
handle this through its hooks mechanism.</p>
</div>
<div class="section" id="code-scanning">
<h3><a class="toc-backref" href="#id86">code scanning</a></h3>
<p>Like modulefinder, <tt class="docutils literal">ImportTracker</tt> scans the byte code of a module,
looking for imports.
In addition it will pick out a module's <tt class="docutils literal">__all__</tt>
attribute, if it is built as a list of constant names. This means that
if a package declares an <tt class="docutils literal">__all__</tt> list as a list of names,
ImportTracker will track those names if asked to analyze
<tt class="docutils literal">package.*</tt>. The code scan also notes the occurance of
<tt class="docutils literal">__import__</tt>, <tt class="docutils literal">exec</tt> and <tt class="docutils literal">eval</tt>, and can issue warnings when
they are found.</p>
<p>The code scanning also keeps track (as well as it can) of the context of an
import. It recognizes when imports are found at the top-level, and when they
are found inside definitions (deferred imports). Within that, it also tracks
whether the import is inside a condition (conditional imports).</p>
</div>
<div class="section" id="hooks">
<h3><a class="toc-backref" href="#id87">Hooks</a></h3>
<p>In modulefinder, scanning the code takes the place of executing the
code object. <tt class="docutils literal">ExtensionModules</tt>, of course, don't get scanned, so
there needs to be a way of recording any imports they do.</p>
<p>Please read <a class="reference internal" href="#listing-hidden-imports">Listing Hidden Imports</a> for more information.</p>
<p><tt class="docutils literal">ImportTracker</tt> goes further and allows a module to be hooked (after it has been
scanned, but before analyze_one is done with it).</p>
</div>
<div class="section" id="warnings">
<h3><a class="toc-backref" href="#id88">Warnings</a></h3>
<p><tt class="docutils literal">ImportTracker</tt> has a <tt class="docutils literal">getwarnings()</tt> method that returns all the
warnings accumulated by the instance, and by the <tt class="docutils literal">Module</tt> instances
in its modules dict. Generally, it is <tt class="docutils literal">ImportTracker</tt> who will
accumulate the warnings generated during the structural phase, and
<tt class="docutils literal">Modules</tt> that will get the warnings generated during the code scan.</p>
<p>Note that by using a hook module, you can silence some particularly tiresome
warnings, but not all of them.</p>
</div>
<div class="section" id="cross-reference">
<h3><a class="toc-backref" href="#id89">Cross Reference</a></h3>
<p>Once a full analysis (that is, an <tt class="docutils literal">analyze_r</tt> call) has been done,
you can get a cross reference by using <tt class="docutils literal">getxref()</tt>. This returns a
list of tuples. Each tuple is <tt class="docutils literal">(modulename, importers)</tt>, where
importers is a list of the (fully qualified) names of the modules
importing <tt class="docutils literal">modulename</tt>. Both the returned list and the importers
list are sorted.</p>
</div>
</div>
</div>
<div class="section" id="outdated-features">
<h1><a class="toc-backref" href="#id90">Outdated Features</a></h1>
<p>The following sections document features of <cite>PyInstaller</cite> that
are still present in the code but are rarely used and may no longer work.</p>
<div class="section" id="windows-com-server-support">
<h2><a class="toc-backref" href="#id91">Windows COM Server Support</a></h2>
<blockquote>
<dl class="docutils">
<dt>Recent rename:</dt>
<dd>./utils/MakeComServer.py  - ./utils/make_comserver.py</dd>
</dl>
<p>and after python setup.py install there will be command
'pyi-make_comserver'</p>
</blockquote>
<p>A Windows COM server is a Windows program the uses
<a class="reference external" href="http://www.microsoft.com/com/default.mspx">Microsoft COM</a> (Component Object Model) technology.
If you write such a program in Python you can bundle it with <cite>PyInstaller</cite>,
but you must prepare a special spec file and name the spec
file, not your script, to the pyinstaller command.</p>
<p>To prepare the spec file use the command</p>
<blockquote>
<tt class="docutils literal"><span class="pre">pyi-make_comserver</span></tt> [<em>options</em>] myscript.py</blockquote>
<p>Alternatively you can use the <tt class="docutils literal">make_comserver.py</tt> script
in the <tt class="docutils literal">utils</tt> subdirectory of the <cite>PyInstaller</cite> folder.</p>
<p>This will generate a spec file <tt class="docutils literal">myscript.spec</tt>
and a new script <tt class="docutils literal">drivescript.py</tt>.
From this point you build your project using the pyinstaller
command, naming the spec file as its input.</p>
<p>pyi-make_comserver assumes that your top level code (registration etc.) is
&quot;normal&quot;. If it's not, you will have to edit the generated script.</p>
<p>These options are allowed with the pyi-make_comserver command:</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">--debug</span></kbd></td>
<td>Use the debug (verbose) version of the bootloader in the executable.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">--verbose</span></kbd></td>
<td>Register the COM server(s) with the quiet flag off.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">--ascii</span></kbd></td>
<td>do not include Unicode support modules.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--out=<var>output_path</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Generate <tt class="docutils literal">drivescript.py</tt> and the spec file in <em>output_path</em>.</td></tr>
</tbody>
</table>
<p>If you have the win32dbg package installed, you can use it with the generated
COM server. In <tt class="docutils literal">drivescript.py</tt>, set <tt class="docutils literal">debug=1</tt> in the registration line.</p>
<p>Caution: the inprocess COM server support will not work when the client
process already has Python loaded. It would be rather tricky to
non-obtrusively hook into an already running Python, but the show-stopper is
that the Python/C API won't let us find out which interpreter instance to
hook into. (If this is important to you, you might experiment with using
apartment threading, which seems the best possibility to get this to work). To
use a &quot;frozen&quot; COM server from a Python process, you'll have to load it as an
exe:</p>
<pre class="literal-block">
o = win32com.client.Dispatch(progid,
                 clsctx=pythoncom.CLSCTX_LOCAL_SERVER)
</pre>
</div>
<div class="section" id="building-optimized">
<h2><a class="toc-backref" href="#id92">Building Optimized</a></h2>
<p>There are two facets to running optimized: gathering <tt class="docutils literal">.pyo</tt>'s,
and setting the
<tt class="docutils literal">Py_OptimizeFlag</tt>. Installer will gather <tt class="docutils literal">.pyo</tt>'s if it is run optimized:</p>
<pre class="literal-block">
python -O pyinstaller.py ...
</pre>
<p>The <tt class="docutils literal">Py_OptimizeFlag</tt> will be set if you use a <tt class="docutils literal"><span class="pre">('O','','OPTION')</span></tt> in one of
the <tt class="docutils literal">TOCs</tt> building the <tt class="docutils literal">EXE</tt>:</p>
<pre class="literal-block">
exe = EXE(pyz,
          a.scripts + [('O','','OPTION')],
          ...
</pre>
<p>See <a class="reference internal" href="#using-spec-files">Using Spec Files</a> for details.</p>
</div>
<div class="section" id="iu-py-an-imputil-replacement">
<span id="iu-py"></span><h2><a class="toc-backref" href="#id93"><tt class="docutils literal">iu.py</tt>: An <em>imputil</em> Replacement</a></h2>
<p>Module <tt class="docutils literal">iu</tt> grows out of the pioneering work that Greg Stein did
with <a class="reference external" href="http://docs.python.org/2.7/library/imputil.html">imputil</a> (actually, it includes some verbatim <tt class="docutils literal">imputil</tt>
code, but since Greg didn't copyright it, we won't mention it).
Both modules can take over Python's builtin import and ease writing of at
least certain kinds of import hooks.</p>
<p><tt class="docutils literal">iu</tt> differs from <tt class="docutils literal">imputil</tt> in that it:</p>
<ul class="simple">
<li>is faster</li>
<li>better emulates the builtin import</li>
<li>is more manageable</li>
</ul>
<p>There is an <tt class="docutils literal">ImportManager</tt> which provides the replacement for builtin import
and hides all the semantic complexities of a Python import request from its
delegates.</p>
<div class="section" id="importmanager">
<h3><a class="toc-backref" href="#id94"><tt class="docutils literal">ImportManager</tt></a></h3>
<p><tt class="docutils literal">ImportManager</tt> formalizes the concept of a metapath. This concept implicitly
exists in native Python in that builtins and frozen modules are searched
before <tt class="docutils literal">sys.path</tt>, (on Windows there's also a search of the registry, while on
Mac, resources may be searched). This metapath is a list populated with
<tt class="docutils literal">ImportDirector</tt> instances. There are <tt class="docutils literal">ImportDirector</tt> subclasses
for builtins, frozen modules, (on Windows) modules found through the
registry and a <tt class="docutils literal">PathImportDirector</tt> for handling <tt class="docutils literal">sys.path</tt>. For a
top-level import (that is, not an import of a module in a package),
<tt class="docutils literal">ImportManager</tt> tries each director on its metapath until one
succeeds.</p>
<p><tt class="docutils literal">ImportManager</tt> hides the semantic complexity of an import from the directors.
It is up to the <tt class="docutils literal">ImportManager</tt> to decide if an import is relative or absolute;
to see if the module has already been imported; to keep <tt class="docutils literal">sys.modules</tt> up to
date; to handle the fromlist and return the correct module object.</p>
</div>
<div class="section" id="importdirector">
<h3><a class="toc-backref" href="#id95"><tt class="docutils literal">ImportDirector</tt></a></h3>
<p>An <tt class="docutils literal">ImportDirector</tt> just needs to respond to <tt class="docutils literal">getmod(name)</tt> by
returning a module object or <tt class="docutils literal">None</tt>. As you will see, an
<tt class="docutils literal">ImportDirector</tt> can consider name to be atomic - it has no need to
examine name to see if it is dotted.</p>
<p>To see how this works, we need to examine the <tt class="docutils literal">PathImportDirector</tt>.</p>
</div>
<div class="section" id="pathimportdirector">
<h3><a class="toc-backref" href="#id96"><tt class="docutils literal">PathImportDirector</tt></a></h3>
<p>The <tt class="docutils literal">PathImportDirector</tt> subclass manages a list of names, most
notably <tt class="docutils literal">sys.path</tt>. To do so, it maintains a shadowpath, a
dictionary mapping the names on its pathlist (eg, <tt class="docutils literal">sys.path</tt>) to
their associated <tt class="docutils literal">Owners</tt>. (It could do this directly, but the
assumption that sys.path is occupied solely by strings seems
ineradicable.) <tt class="docutils literal">Owners</tt> of the appropriate kind are created as
needed (if all your imports are satisfied by the first two elements of
<tt class="docutils literal">sys.path</tt>, the <tt class="docutils literal">PathImportDirector</tt>'s shadowpath will only have
two entries).</p>
</div>
<div class="section" id="owner">
<h3><a class="toc-backref" href="#id97"><tt class="docutils literal">Owner</tt></a></h3>
<p>An <tt class="docutils literal">Owner</tt> is much like an <tt class="docutils literal">ImportDirector</tt> but manages a much
more concrete piece of turf. For example, a <tt class="docutils literal">DirOwner</tt> manages one
directory. Since there are no other officially recognized
filesystem-like namespaces for importing, that's all that's included
in <tt class="docutils literal">iu</tt>, but it's easy to imagine <tt class="docutils literal"><span class="pre">Owner``s</span> for zip files (and I have
one for my own <span class="pre">``.pyz</span></tt> archive format) or even URLs.</p>
<p>As with <tt class="docutils literal">ImportDirectors</tt>, an <tt class="docutils literal">Owner</tt> just needs to respond to
<tt class="docutils literal">getmod(name)</tt> by returning a module object or <tt class="docutils literal">None</tt>, and it can
consider name to be atomic.</p>
<p>So structurally, we have a tree, rooted at the <tt class="docutils literal">ImportManager</tt>. At
the next level, we have a set of <tt class="docutils literal">ImportDirectors</tt>. At least one of
those directors, the <tt class="docutils literal">PathImportDirector</tt> in charge of <tt class="docutils literal">sys.path</tt>,
has another level beneath it, consisting of <tt class="docutils literal">Owners</tt>. This much of
the tree covers the entire top-level import namespace.</p>
<p>The rest of the import namespace is covered by treelets, each rooted in a
package module (an <tt class="docutils literal">__init__.py</tt>).</p>
</div>
<div class="section" id="packages">
<h3><a class="toc-backref" href="#id98">Packages</a></h3>
<p>To make this work, <tt class="docutils literal">Owners</tt> need to recognize when a module is a
package. For a <tt class="docutils literal">DirOwner</tt>, this means that name is a subdirectory
which contains an <tt class="docutils literal">__init__.py</tt>. The <tt class="docutils literal">__init__</tt> module is loaded
and its <tt class="docutils literal">__path__</tt> is initialized with the subdirectory. Then, a
<tt class="docutils literal">PathImportDirector</tt> is created to manage this <tt class="docutils literal">__path__</tt>. Finally
the new <tt class="docutils literal">PathImportDirector</tt>'s <tt class="docutils literal">getmod</tt> is assigned to the
package's <tt class="docutils literal">__importsub__</tt> function.</p>
<p>When a module within the package is imported, the request is routed
(by the <tt class="docutils literal">ImportManager</tt>) directly to the package's <tt class="docutils literal">__importsub__</tt>.
In a hierarchical namespace (like a filesystem), this means that
<tt class="docutils literal">__importsub__</tt> (which is really the bound getmod method of a
<tt class="docutils literal">PathImportDirector</tt> instance) needs only the module name, not the
package name or the fully qualified name. And that's exactly what it
gets. (In a flat namespace - like most archives - it is perfectly easy
to route the request back up the package tree to the archive
<tt class="docutils literal">Owner</tt>, qualifying the name at each step.)</p>
</div>
<div class="section" id="possibilities">
<h3><a class="toc-backref" href="#id99">Possibilities</a></h3>
<p>Let's say we want to import from zip files. So, we subclass <tt class="docutils literal">Owner</tt>.
The <tt class="docutils literal">__init__</tt> method should take a filename, and raise a
<tt class="docutils literal">ValueError</tt> if the file is not an acceptable <tt class="docutils literal">.zip</tt> file. (When a
new name is encountered on <tt class="docutils literal">sys.path</tt> or a package's <tt class="docutils literal">__path__</tt>,
registered Owners are tried until one accepts the name.) The
<tt class="docutils literal">getmod</tt> method would check the zip file's contents and return
<tt class="docutils literal">None</tt> if the name is not found. Otherwise, it would extract the
marshalled code object from the zip, create a new module object and
perform a bit of initialization (12 lines of code all told for my own
archive format, including initializing a package with its
<tt class="docutils literal">__subimporter__</tt>).</p>
<p>Once the new <tt class="docutils literal">Owner</tt> class is registered with <tt class="docutils literal">iu</tt>, you can put a
zip file on <tt class="docutils literal">sys.path</tt>. A package could even put a zip file on its
<tt class="docutils literal">__path__</tt>.</p>
</div>
<div class="section" id="compatibility">
<h3><a class="toc-backref" href="#id100">Compatibility</a></h3>
<p>This code has been tested with the PyXML, mxBase and Win32 packages,
covering over a dozen import hacks from manipulations of <tt class="docutils literal">__path__</tt>
to replacing a module in <tt class="docutils literal">sys.modules</tt> with a different one.
Emulation of Python's native import is nearly exact, including the
names recorded in <tt class="docutils literal">sys.modules</tt> and module attributes (packages
imported through <tt class="docutils literal">iu</tt> have an extra attribute - <tt class="docutils literal">__importsub__</tt>).</p>
</div>
<div class="section" id="performance">
<h3><a class="toc-backref" href="#id101">Performance</a></h3>
<p>In most cases, <tt class="docutils literal">iu</tt> is slower than builtin import (by 15 to 20%) but
faster than <tt class="docutils literal">imputil</tt> (by 15 to 20%). By inserting archives at the
front of <tt class="docutils literal">sys.path</tt> containing the standard lib and the package
being tested, this can be reduced to 5 to 10% slower (or, on my 1.52
box, 10% faster!) than builtin import. A bit more can be shaved off by
manipulating the <tt class="docutils literal">ImportManager</tt>'s metapath.</p>
</div>
<div class="section" id="limitations">
<h3><a class="toc-backref" href="#id102">Limitations</a></h3>
<p>This module makes no attempt to facilitate policy import hacks. It is easy to
implement certain kinds of policies within a particular domain, but
fundamentally iu works by dividing up the import namespace into independent
domains.</p>
<p>Quite simply, I think cross-domain import hacks are a very bad idea. As author
of the original package on which <cite>PyInstaller</cite> is based, McMillan worked with
import hacks for many years. Many of them are highly fragile; they often rely
on undocumented (maybe even accidental) features of implementation.
A cross-domain import hack is not likely to work with PyXML, for example.</p>
<p>That rant aside, you can modify <tt class="docutils literal">ImportManger</tt> to implement
different policies. For example, a version that implements three
import primitives: absolute import, relative import and
recursive-relative import. No idea what the Python syntax for those
should be, but <tt class="docutils literal">__aimport__</tt>, <tt class="docutils literal">__rimport__</tt> and <tt class="docutils literal">__rrimport__</tt>
were easy to implement.</p>
</div>
<div class="section" id="iu-usage">
<h3><a class="toc-backref" href="#id103">iu Usage</a></h3>
<p>Here's a simple example of using <tt class="docutils literal">iu</tt> as a builtin import replacement.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import iu
&gt;&gt;&gt; iu.ImportManager().install()
&gt;&gt;&gt;
&gt;&gt;&gt; import DateTime
&gt;&gt;&gt; DateTime.__importsub__
&lt;method PathImportDirector.getmod
  of PathImportDirector instance at 825900&gt;
&gt;&gt;&gt;
</pre>
</blockquote>
</div>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="source/Manual.rst">View document source</a>.
Generated on: 2015-05-29 12:12 UTC.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
